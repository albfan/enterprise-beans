[[a608]]
== Session Bean Component Contract

This chapter specifies the contract between a
session bean and its container. It defines the life cycle of the session
bean instances.

This chapter defines the developer’s view of
session bean state management and the container’s responsibilities for
managing session bean state.

=== Overview

A session bean
instance is an instance of the session bean class. It holds the session
object’s state.

A session bean instance is an extension of
the client that creates it:

* In the case of a stateful session bean, its
fields contain *conversational state*  on
behalf of the session object’s client. This state describes the
conversation represented by a specific client/session object pair.

* It typically reads and updates data in a
database on behalf of the client.

* In the case of a stateful session bean, its
lifetime is controlled by the client.

_A container may also terminate a session bean
instance’s life after a Deployer-specified timeout or as a result of the
failure of the server on which the bean instance is running. For this
reason, a client should be prepared to recreate a new session object if
it loses the one it is using._

Typically, a session object’s conversational
state is not written to the database. A session Bean Provider simply
stores it in the session bean instance’s fields and assumes its value is
retained for the lifetime of the instance. A developer may use an
extended persistence context to store a stateful session bean’s
persistent conversational state. See the document _Java Persistence
API_ specification <<a9851>>.

A session bean that does not make use of the
Java Persistence API must explicitly manage
cached database data. A session bean
instance must write any cached database updates prior to a transaction
completion, and it must refresh its copy of any potentially stale
database data at the beginning of the next transaction. A session bean
must also refresh any `java.sql.Statement` objects before they are used
in a new transaction context. Use of the Java Persistence API provides a
session bean with automatic management of database data, including the
automatic flushing of cached database updates upon transaction commit.
See <<a9851>>.

The container manages the life cycle of the
session bean instances. It notifies the instances when bean action may
be necessary, and it provides a full range of services to ensure that
the session bean implementation is scalable and can support a large
number of clients.

A session bean may be invoked either
_synchronously_ or _asynchronously_.

A session bean may be either:

* _stateless_—the session bean instances
contain no conversational state between methods; any instance can be
used for any client.

* _stateful_—the session bean instances
contain conversational state which must be retained across methods and
transactions.

* _singleton_—a single session bean instance is
shared between clients and supports concurrent access.

=== Conversational State of a Stateful Session Bean

The
conversational state of a _stateful_ session object is defined as the
session bean instance’s field values, its associated interceptors and
their instance field values, plus the transitive closure of the objects
from these instances’ fields reached by following Java object
references.

To efficiently manage the size of its working
set, a session bean container may need to temporarily transfer the state
of an idle _stateful_ session bean instance to some form of secondary
storage. The transfer from the working set to secondary storage is
called instance _passivation_. The transfer back is called _activation_.

In advanced cases, a session object’s
conversational state may contain open resources, such as open sockets
and open database cursors. A container cannot retain such open resources
when a session bean instance is passivated. A developer of a stateful
session bean must close and open the resources in the `PrePassivate` and
`PostActivate` lifecycle callback interceptor
methods.footnote:a10228[Note that this requirement does not apply to the 
`EntityManager` and `EntityManagerFactory` objects.]

A container may only passivate a stateful
session bean instance when the instance is _not_ in a transaction.

A container must not passivate a stateful
session bean that is designated as not passivation capable. See <<a1053>> 
on how to disable passivation of stateful session beans.

A container must not passivate a
stateful session bean with an extended persistence context unless the
following conditions are met:footnote:a10229[The container is not 
permitted to destroy a stateful session bean instance because it does 
not meet these requirements.]

* All the entities in the persistence context
are serializable.

* The EntityManager is serializable.

A stateless session bean is never passivated.

A singleton session bean is never passivated.

[[a639]]
==== Instance Passivation and Conversational State

The Bean Provider
is required to ensure that the `PrePassivate` method leaves the instance
fields and the fields of its associated interceptors ready to be
serialized by the container. The objects that are assigned to the
instance’s _non-transient_ fields and the _non-transient_ fields of
its interceptors after the `PrePassivate` method completes must be one
of the following.

* A serializable object.footnote:a10230[Note that the Java Serialization 
protocol dynamically determines whether or not an object is serializable. 
This means that it is possible to serialize an object of a serializable 
subclass of a non-serializable declared field type.]

* A `null`.

* A reference to an enterprise bean’s local or
remote business interface.

* A reference to an enterprise bean’s
no-interface view.

* A reference to an enterprise bean’s remote
component interface, even if the stub class is not serializable.

* A reference to an enterprise bean’s remote
home interface, even if the stub class is not serializable.

* A reference to an entity
bean’s footnote:a10230[] local component interface, even if it is
not serializable.

* A reference to an entity
bean’s footnote:a10231[Component contract and client view of entity 
beans are described in the EJB Optional Features document 
<<a9890>>.] local home interface, even if it is not serializable.

* A reference to the `SessionContext` object,
even if it is not serializable.

* A reference to the environment naming context
(that is, the `java:comp/env` JNDI context) or any of its subcontexts.

* A reference to the `UserTransaction` interface.

* A reference to a resource manager connection
factory.footnote:a10232[Except for the `javax.mail.Session` resource 
manager connection factory.]

* A reference to a container-managed
`EntityManager` object, even if it is not serializable.

* A reference to an `EntityManagerFactory`
object obtained via injection or JNDI lookup, even if it is not
serializable.

* A reference to a `javax.ejb.Timer` object.

* An object that is not directly serializable,
but becomes serializable by replacing the references to an enterprise
bean’s business interface, an enterprise bean’s home and component
interfaces, the references to the `SessionContext` object, the
references to the `java:comp/env` JNDI context and its subcontexts, the
references to the `UserTransaction` interface, and the references to the
`EntityManager` and/or `EntityManagerFactory` by serializable objects
during the object’s serialization.

_This means, for example, that the Bean
Provider must close all JDBC(TM) connections in the `PrePassivate` method
and assign the instance’s fields storing the connections to `null`._

_The last bulleted item covers cases such as
storing Collections of component interfaces in the conversational state._

The Bean Provider must assume that the
content of `transient` fields may be lost between the `PrePassivate` and
`PostActivate` notifications. Therefore, the Bean Provider should not
store in a `transient` field a reference to any of the following objects:
`SessionContext` object; environment JNDI naming context and any its
subcontexts; business interfaces; home and component interfaces;
`EntityManager` interface; `EntityManagerFactory` interface;
`UserTransaction` interface.

_The restrictions on the use of transient
fields ensure that containers can use Java Serialization during
passivation and activation._

The following are
the requirements for the container:

* The container performs the Java programming
language Serialization (or its equivalent) of the instance’s state (and
its interceptors’ state) after it invokes the `PrePassivate` method on the
instance and its interceptors.

* The container must be able to properly save
and restore the reference to the business interfaces and home and
component interfaces of the enterprise beans stored in the instance’s
state even if the classes that implement the object references are not
serializable.

* The container may use, for example, the
object replacement technique that is part of the
`java.io.ObjectOutputStream` and `java.io.ObjectInputStream` protocol to
externalize the home and component references.

* The container must be able to properly save
and restore references to timers stored in the instance’s state even if
the classes that implement the timers are not serializable.

* If the session bean instance stores in its
conversational state an object reference to the
`javax.ejb.SessionContext` interface, the container must be able to save
and restore the reference across the instance’s passivation. The
container can replace the original `SessionContext` object with a
different and functionally equivalent `SessionContext` object during
activation.

* If the session bean instance stores in its
conversational state an object reference to the `java:comp/env` JNDI
context or its subcontext, the container must be able to save and
restore the object reference across the instance’s passivation. The
container can replace the original object with a different and
functionally equivalent object during activation.

* If the session
bean instance stores in its conversational state an object reference to
the `UserTransaction` interface, the container must be able to save and
restore the object reference across the instance’s passivation. The
container can replace the original object with a different and
functionally equivalent object during activation.

* If the session
bean instance stores in its conversational state an object reference to
a container-managed `EntityManager` or to an `EntityManagerFactory`
obtained via injection or JNDI lookup, the container must be able to
save and restore the object reference across the instance’s passivation.

* The container may destroy a session bean
instance if the instance does not meet the requirements for
serialization after `PrePassivate`.

* While the container is not required to use
the Serialization protocol for the Java programming language to store
the state of a passivated session instance, it must achieve the
equivalent result. The one exception is that containers are not required
to reset the value of `transient` fields during
activation.footnote:a10234[This is to allow the container to swap out an 
instance’s state through techniques other than the Java Serialization 
protocol. For example, the container’s Java Virtual Machine implementation 
may use a block of memory to keep the instance’s variables, and the 
container swaps the whole memory block to the disk instead of performing 
Java Serialization on the instance.] Declaring the session bean’s fields
as transient is, in general, discouraged.

==== The Effect of Transaction Rollback on Conversational State

A session
object’s conversational state is not transactional. It is not
automatically rolled back to its initial state if the transaction in
which the object has participated rolls back.

If a rollback
could result in an inconsistency between a session object’s
conversational state and the state of the underlying database, the bean
developer (or the application development tools used by the developer)
must use the `afterCompletion` notification to manually reset its state.

=== Protocol Between a Session Bean Instance and its Container

Containers themselves make no actual service
demands on the session bean instances. The container makes calls on a
bean instance to provide it with access to container services and to
deliver notifications issued by the container.

==== Required Session Bean Metadata

A session bean must be annotated or denoted
in the deployment descriptor as a stateless, stateful, or singleton
session bean. A stateless session bean must be annotated with the
`Stateless` annotation or denoted in the deployment descriptor as a
stateless session bean. A stateful session bean must be annotated with
the `Stateful` annotation or denoted in the deployment descriptor as a
stateful session bean. A singleton session bean must be annotated with
the `Singleton` annotation or denoted in the deployment descriptor as a
singleton session bean. The `Stateful`, `Singleton`, and `Stateless`
annotations are component-defining annotations and are applied to the
bean class.

==== Dependency Injection

A session bean may use dependency injection
mechanisms to acquire references to resources or other objects in its
environment (see <<a3613>>). If a session bean makes use of dependency 
injection, the container injects these references after the bean instance 
is created, and before any business methods are invoked on the bean 
instance. If a dependency on the `SessionContext` is declared, or if the 
bean class implements the optional `SessionBean` interface (see <<a722>>), 
the `SessionContext` is also injected at this time. If dependency injection
fails, the bean instance is discarded.

Under the EJB 3.x API, the bean class may
acquire the `SessionContext` interface through dependency injection
without having to implement the `SessionBean` interface. In this case,
the `Resource` annotation (or `resource-env-ref` deployment descriptor
element) is used to denote the bean’s dependency on the `SessionContext`
. See <<a3613>>.

[[a682]]
==== The SessionContext Interface

If the bean
specifies a dependency on the `SessionContext` interface (or if the bean
class implements the `SessionBean` interface), the container must
provide the session bean instance with a `SessionContext` object. This
gives the session bean instance access to the instance’s context
maintained by the container. The `SessionContext` interface has the
following methods:

* The `getCallerPrincipal` method returns the
`java.security.Principal` that identifies the invoker.

* The `isCallerInRole` method tests if the
session bean instance’s caller has a particular role.

* The `setRollbackOnly` method allows the
instance to mark the current transaction such that the only outcome of
the transaction is a rollback. Only instances of a session bean with
container-managed transaction demarcation are permitted to use this
method.

* The `getRollbackOnly` method allows the
instance to test if the current transaction has been marked for
rollback. Only instances of a session bean with container-managed
transaction demarcation are permitted to use this method.

* The `getUserTransaction` method returns the
`javax.transaction.UserTransaction` interface. The instance can use this
interface to demarcate transactions and to obtain transaction status.
Only instances of a session bean with bean-managed transaction
demarcation are permitted to use this method.

* The `getTimerService` method returns the
`javax.ejb.TimerService` interface. Only stateless session beans and
singleton session beans are permitted to use this method. Stateful
session beans cannot be timed objects.

* The `getBusinessObject(java.lang.Class<T> businessInterface)` method 
returns a business object reference to the
session bean’s business interface or no-interface view. In the case of
the no-interface view, the argument is of the type of the bean class.
Only session beans with an EJB 3.x business interface or no-interface
view are permitted to call this method. +
 +
If a subsequent invocation is made on the
result of `getBusinessObject`, then:

** For a stateless session bean, the invocation
will be delivered to another stateless session bean instance.

** For a stateful session bean or singleton
session bean, the invocation will be delivered to the bean instance that
returned the reference. The existing rules regarding reentrancy would
then apply.

* The `getInvokedBusinessInterface` method
returns the session bean business interface or no-interface view (bean
class) type through which the bean was invoked.

* The `getEJBObject` method returns the session
bean’s remote component interface. Only session beans with a remote
EJBObject interface are permitted to call this method.

* The `getEJBHome` method returns the session
bean’s remote home interface. Only session beans with a remote home
interface are permitted to call this method.

* The `getEJBLocalObject` method returns the
session bean’s local component interface. Only session beans with a
local `EJBLocalObject` interface are permitted to call this method.

* The `getEJBLocalHome` method returns the
session bean’s local home interface. Only session beans with a local
home interface are permitted to call this method.

* The `lookup` method enables the session bean
to look up its environment entries in the JNDI naming context.

* The `wasCancelCalled` method enables an
asynchronous session bean method to check whether the client invoked its
`Future.cancel` method. The `SessionContext.wasCancelCalled` method only
returns true if the cancel method was invoked on the client `Future`
object corresponding to the currently executing business method and the
`mayInterruptIfRunning` parameter was set to true.

* The `getContextData` method enables a
business method, lifecycle callback method, or timeout method to
retrieve or update the interceptor and/or webservices context data
associated with its invocation.

===== Use of the MessageContext Interface by Session Beans

A session bean that implements a web service
endpoint using the JAX-WS contracts should use the JAX-WS
`WebServiceContext`, which can be injected by use of the `Resource`
annotation. The `WebServiceContext` interface allows the session bean
instance to see the SOAP message for the web service endpoint, as well
as the properties set by the JAX-WS message handlers, if any. The
session bean may use the `WebServiceContext` interface to set properties
for the JAX-WS message handlers, if any. See <<a9881>>.

The `javax.xml.ws.handler.MessageContext`<<a9881>> is also
accessible to interceptors for session bean web service endpoints. See 
<<a2029>>.

[[a705]]
==== Session Bean Lifecycle Callback Interceptor Methods

The following lifecycle event callbacks are
supported for session beans. With the exception of `AroundConstruct`
lifecycle callback interceptors (see <<a9887>>), all
interceptor methods may be defined directly on the bean class or on a
separate interceptor class. See <<a1487>> and <<a2004>>.

* `AroundConstruct`

* `PostConstruct`

* `PreDestroy`

* `PostActivate`

* `PrePassivate`

The `PostConstruct` callback invocations
occur before the first business method invocation on the bean instance.
This is at a point after which any dependency injection has been
performed by the container.

The `PostConstruct` lifecycle callback
interceptor methods execute in an unspecified security context.

The `PostConstruct` lifecycle callback
interceptor methods for a stateless session bean execute in an
unspecified transaction context. The `PostConstruct` lifecycle callback
interceptor methods for a singleton session bean execute in a
transaction context determined by the bean’s transaction management type
and any applicable transaction attribute. The `PostConstruct` lifecycle
callback interceptor methods for a stateful session bean execute in a
transaction context determined by the lifecycle callback method's
transaction attribute.

The `PreDestroy` callback notification
signals that the instance is in the process of being removed by the
container. In the `PreDestroy` lifecycle callback interceptor methods,
the instance typically releases the resources that it has been holding.

The `PreDestroy` lifecycle callback
interceptor methods execute in an unspecified security context.

The `PreDestroy` lifecycle callback interceptor
methods for a stateless session bean execute in an unspecified
transaction context. The `PreDestroy` lifecycle callback interceptor
methods for a singleton session bean execute in a transaction context
determined by the bean’s transaction management type and any applicable
transaction attribute. The `PreDestroy` lifecycle callback interceptor
methods for a stateful bean execute in a transaction context determined
by the lifecycle callback method’s transaction attribute.

The `PrePassivate` and `PostActivate`
lifecycle callback interceptor methods are only called on a stateful
session bean instance if the bean is passivation capable. By default a
stateful session bean is passivation capable. See <<a1053>> on how to 
disable passivation of a stateful session bean.

The `PrePassivate` callback notification
signals the intent of the container to passivate the instance. The
`PostActivate` notification signals the instance it has just been
reactivated. Because containers automatically maintain the
conversational state of a stateful session bean instance when it is
passivated, these notifications are not needed for most session beans.
Their purpose is to allow stateful session beans to maintain those open
resources that need to be closed prior to an instance’s passivation and
then reopened during an instance’s activation.

The `PrePassivate` and `PostActivate`
lifecycle callback interceptor methods execute in an unspecified
security context.

The `PrePassivate` and `PostActivate`
lifecycle callback interceptor methods execute in a transaction context
determined by the lifecycle callback method's transaction attribute.

[[a722]]
==== The SessionBean Interface

The session bean class is not required to
implement the _SessionBean_ interface or the _Serializable_ interface.
Interceptor classes for the bean are likewise not required to implement
the _Serializable_ interface.

 _The SessionBean interface was required to
be implemented by the session bean class in earlier versions of the
Enterprise JavaBeans specification. Under the EJB 3.x API, the
functionality previously provided by the SessionBean interface is
available to the bean class through selective use of dependency
injection (of the SessionContext) and optional lifecycle callback
interceptor methods._

The _SessionBean_ interface defines four
methods: _setSessionContext_ , _ejbRemove_ , _ejbPassivate_ , and
_ejbActivate_ .

The _setSessionContext_
 method is called by the bean’s container to
associate a session bean instance with its context maintained by the
container. Typically a session bean instance retains its session context
as part of its state.

The _ejbRemove_ notification signals that the
instance is in the process of being removed by the container. In the
_ejbRemove_  method, the instance typically
releases the same resources that it releases in the _ejbPassivate_
 method.

Under the EJB 3.x API, the bean class may
optionally define a _PreDestroy_ lifecycle callback interceptor method
for notification of the container’s removal of the bean instance.

The _ejbPassivate_ notification signals the
intent of the container to passivate the instance. The _ejbActivate_
notification signals the instance it has just been reactivated. Their
purpose is to allow stateful session beans to maintain those open
resources that need to be closed prior to an instance’s passivation and
then reopened during an instance’s activation. The _ejbPassivate_ and
_ejbActivate_ methods are only called on stateful session bean
instances.

Under the EJB 3.x API, the bean class may
optionally define _PrePassivate_ and/or _PostActivate_ lifecycle
callback interceptor methods for notification of the
passivation/activation of the bean instance.

This specification requires that the
_ejbRemove_ , _ejbActivate_ , and _ejbPassivate_ methods of the
_SessionBean_ interface, and the _ejbCreate_ method of a stateless
session bean be treated as _PreDestroy_ , _PostActivate_ ,
_PrePassivate_ and _PostConstruct_ life cycle callback interceptor
methods, respectively.

If the session bean implements the
_SessionBean_ interface, the _PreDestroy_ annotation on the bean class
can only be applied to the _ejbRemove_ method; the _PostActivate_
annotation can only be applied to the _ejbActivate_ method; the
_PrePassivate_ annotation can only be applied to the _ejbPassivate_
method. Similar requirements apply to use of deployment descriptor
metadata as an alternative to the use of annotations.

[[a736]]
==== The Session Synchronization Notifications for Stateful Session Beans

A stateful
session bean class can optionally implement the javax.ejb.
_SessionSynchronization_ interface or annotate methods using the
individual AfterBegin, BeforeCompletion, and AfterCompletion
annotations. The deployment descriptor may also be used to declare the
individual session synchronization methods. These provide the session
bean instances with transaction
synchronization notifications. The instances can use these
notifications, for example, to manage database data they may cache
within transactions—e.g., if the Java Persistence API is not used. A
stateful session bean class may use either the
javax.ejb.SessionSynchronization interface or the session
synchronization annotations, but not both. If annotation are used, there
must be at most one _AfterBegin_ method, one _BeforeCompletion_ method,
and one _AfterCompletion_ method for the bean.

The _afterBegin_
notification signals a session bean instance that a new transaction has
begun. The container invokes this method before the first business
method within a transaction (which is not necessarily at the beginning
of the transaction). The _afterBegin_ notification is invoked with the
transaction context. The instance may do any database work it requires
within the scope of the transaction.

The _beforeCompletion_
 notification is issued when a session bean
instance’s client has completed work on its current transaction but
prior to committing the resource managers used by the instance. At this
time, the instance should write out any database updates it has cached.
The instance can cause the transaction to roll back by invoking the
setRollbackOnly method on its
_SessionContext_ object.

The _afterCompletion_
 notification signals that the current
transaction has completed. A completion status of _true_ indicates that
the transaction has committed. A status of _false_ indicates that a
rollback has occurred. Since a session bean instance’s conversational
state is not transactional, it may need to manually reset its state if a
rollback occurred.

All Container Providers must support the __
session synchronization notifications. If a
bean class implements the _SessionSynchronization_ interface, the
container must invoke the _afterBegin_ , _beforeCompletion_ , and
_afterCompletion_ notifications as required by the specification. If the
bean implementor uses the session synchronization annotations, the
container must invoke only the notifications corresponding to the
annotations that have been used.

If a stateful session bean's PostConstruct,
PreDestroy, PrePassivate or PostActivate lifecycle callback interceptor
method is invoked in the scope of a transaction, session synchronization
callbacks for the transaction are not called on the bean instance.

A session synchronization method can have
public, private, protected, or package level access. A session
synchronization method must not be declared as _final_ or _static_ .

Only a stateful session bean with
container-managed transaction demarcation can receive session
synchronization notifications. Stateless session beans and singleton
session beans must not implement the _SessionSynchronization_ interface
or use the session synchronization annotations.

There is no need for a session bean with
bean-managed transaction demarcation to rely on the synchronization call
backs because the bean is in control of the commit—the bean knows when
the transaction is about to be committed and it knows the outcome of the
transaction commit.

==== Timeout Callbacks for Stateless and Singleton Session Beans

A stateless session bean or singleton session
bean can be registered with the EJB Timer Service for time-based event
notifications. The container invokes the appropriate bean instance
timeout callback method when a timer for the bean has expired. See
link:Ejb.html#a5456[See Timer Service]. Stateful session beans
cannot be registered with the EJB Timer Service, and therefore should
not implement timeout callback methods.

==== Business Method Delegation

The session bean’s business interface,
no-interface view, component interface, or web service endpoint defines
the business methods callable by a client.

The container classes that implement these
are generated by the container tools. The class that implements the
session bean’s business interface and the class that implements the
session bean’s no-interface view and the class that implements a session
bean’s component interface delegate an invocation of a business method
to the matching business method that is implemented in the session bean
class. The class that handles requests to the web service endpoint
invokes the session bean method that matches the web service method
corresponding to the SOAP request.

[[a756]]
==== Session Bean Creation

Except as noted below, the container creates
an instance of a session bean as follows. First, the container calls the
bean class constructor to create a new session bean instance. Second,
the container performs any dependency injection as specified by metadata
annotations on the bean class or by the deployment descriptor. This
includes the bean’s SessionContext, if applicable. Third, the container
calls the _PostConstruct_ lifecycle callback interceptor methods for the
bean, if any. The additional steps described below in sections
link:Ejb.html#a759[See Stateful Session Beans] and
link:Ejb.html#a762[See Stateless Session Beans] apply if the
session bean is invoked through the EJB 2.1 client view APIs.

If an interceptor associated with the session
bean declares an _AroundConstruct_ lifecycle callback interceptor
method, the container follows the rules for the _AroundConstruct
interceptors_ defined in the Interceptors specification
link:Ejb.html#a9887[See Interceptors, version 1.2.
http://jcp.org/en/jsr/detail?id=318.].

[[a759]]
===== Stateful Session Beans

If the bean is a stateful session bean and
the client has used one of the create<METHOD> methods defined in the
session bean’s home or local home interface to create the bean, the
container then calls the instance’s initialization method whose
signature matches the signature of the _create<METHOD>_ invoked by the
client, passing to the method the input parameters sent from the client.
If the bean class is written to the EJB 3.x API, and has been adapted
for use with an earlier client view, this initialization method is a
matching _Init_ method, as designated by use of the _Init_ annotation,
or _init-method_ deployment descriptor element.footnote:a10235[Any 
initialization methods defined for the bean by means of the `init-method` 
deployment descriptor element apply in addition to those defined by means 
of annotations.]
If the bean class was written to the EJB 2.1 or earlier API, this
initialization method is a matching _ejbCreate<METHOD>_ method, as
described in link:Ejb.html#a1498[See ejbCreate<METHOD> Methods].

Each stateful session bean class that has a
home interface must have at least one such initialization method. The
number and signatures of a session bean’s initialization methods are
specific to each session bean class. Since a stateful session bean
represents a specific, private conversation between the bean and its
client, its initialization parameters typically contain the information
the client uses to customize the bean instance for its use.

[[a762]]
===== Stateless Session Beans

A stateless session bean that has an EJB 2.1
local or remote client view has a single _create_ method on its home
interface. In this case, EJB 2.1 required the stateless session bean
class to have a single no-arg _ejbCreate_ method. Under the EJB 3.x API,
it is not required that a stateless session bean have an _ejbCreate_
method, even when it has a home interface. An EJB 3.x stateless session
bean class may have a _PostConstruct_ method, as described in Section
link:Ejb.html#a705[See Session Bean Lifecycle Callback
Interceptor Methods].

If the stateless session bean instance has an
_ejbCreate_ method, the container treats the _ejbCreate_ method as the
instance’s _PostConstruct_ method, and, in this case, the
_PostConstruct_ annotation (or deployment descriptor metadata) can only
be applied to the bean’s _ejbCreate_ method.

Since stateless session bean instances are
typically pooled, the time of the client’s invocation of the _create_
method need not have any direct relationship to the container’s
invocation of the _PostConstruct_ / _ejbCreate_ method on the stateless
session bean instance.

A stateless session bean that provides only a
web service client view has no _create_ method. If the _ejbCreate_
method required by EJB 2.1 is present, it is treated by the container as
the instance’s _PostConstruct_ method, and is invoked when the container
needs to create a new session bean instance in order to service a client
request.

[[a767]]
==== Stateful Session Bean Removal

A stateful session bean written to the EJB
3.x API typically has one or more remove methods designated by means of
the _Remove_ annotation or _remove-method_ deployment descriptor
element.footnote:a10236[Any remove methods defined for the bean by means 
of the `remove-method` deployment descriptor element apply in addition to 
those defined by means of annotations.]
Invocation of the remove method causes
the removal of the stateful session bean after the remove method
successfully completes. If the _Remove_ annotation specifies the value
of _retainIfException_ as _true_ and the invocation of the _Remove_
method throws an application exception, the instance is not removed. The
_retain-if-exception_ subelement of the _remove-method_ deployment
descriptor element may be explicitly specified to override the
_retainIfException_ value specified or defaulted by the _Remove_
annotation. The default value of the _retainIfException_ element is
_false_ . If there are multiple remove methods, their
_retainIfException_ values can differ.

==== Stateful Session Bean Timeout

A Bean Provider or Deployer may optionally
assign a timeout value to a stateful session bean. The stateful session
bean timeout is specified using the StatefulTimeout annotation on the
bean class. It may also be specified using the stateful-timeout
deployment descriptor element. If both are specified, the deployment
descriptor value overrides that of the annotation.

The timeout value is the amount of time a
stateful session bean instance is permitted to remain idle (not receive
any client invocations) before being removed by the container. A timeout
value of -1 indicates that the bean must not be removed due to timeout
for as long as the application is deployed. A timeout value of 0
indicates that the bean is immediately eligible for removal after
becoming idle.

If a stateful session bean timeout is not
designated using this standard metadata, the container determines when
to end the lifetime of the bean, possibly based on vendor-specific
configuration. The details of such configuration are beyond the scope of
the specification.

A stateful session bean instance must not be
removed due to timeout while it is associated with a transaction or
while it is processing a business method or callback. The full stateful
session bean life cycle is covered in link:Ejb.html#a921[See
Stateful Session Beans].

==== Business Method Interceptor Methods for Session Beans

The _AroundInvoke_ interceptor methods are
supported for session beans. These interceptor methods may be defined on
the bean class and/or on interceptor classes, and apply to the handling
of the invocation of the business methods of the bean’s business
interface, no-interface view, component interface, and/or web service
endpoint.

For stateful session beans that use the
session synchronization notifications, the _afterBegin_ notification
occurs before any _AroundInvoke_ method invocations, and the
_beforeCompletion_ notification occurs after all _AroundInvoke_
invocations have finished.

Interceptors are described in
link:Ejb.html#a2004[See Interceptors].

[[a778]]
==== Serializing Session Bean Methods

The following requirements apply to stateless
and stateful session beans. See section link:Ejb.html#a1257[See
Singleton Session Bean Concurrency] for singleton session bean
concurrency requirements.

The container serializes calls to each
stateful and stateless session bean instance. Most containers will
support many instances of a session bean executing concurrently;
however, each instance sees only a serialized sequence of method calls.
Therefore, a stateful or stateless session bean does not have to be
coded as reentrant.

The container must serialize all the
container-invoked callbacks (that is, the
business method interceptor methods, lifecycle callback interceptor
methods, timeout callback methods, beforeCompletion methods, and so on),
and it must serialize these callbacks with the client-invoked business
method calls.

By default, clients are allowed to make
concurrent calls to a stateful session object and the container is
required to serialize such concurrent requests. Note that the container
never permits multi-threaded access to the actual stateful session bean
instance. For this reason, Read/Write method locking metadata, as well
as the bean-managed concurrency mode, are not applicable to stateful
session beans and must not be used.footnote:a10237[The concurrency 
management type `CONTAINER` may be specified for stateful session beans, 
but doing so has no impact on the semantics of concurrency management 
for such beans.] See
link:Ejb.html#a1257[See Singleton Session Bean Concurrency] for
a description of how these concurrency modes and locking types apply to
singleton session beans.

The Bean Provider may optionally specify that
concurrent client requests to a stateful session bean are prohibited.
This is done using the AccessTimeout annotation or the _access-timeout_
deployment descriptor element with a value of 0. In this case, if a
client-invoked business method is in progress on an instance when
another client-invoked call, from the same or different client, arrives
at the same stateful session bean istance, if the second client is a
client of the bean’s business interface or no-interface view, the
concurrent invocation must result in the second client receiving the
_javax.ejb.ConcurrentAccessException_.footnote:a10238[The 
`javax.ejb.ConcurrentAccessException` is a subclass of the 
`javax.ejb.EJBException`. If the business interface is a remote business 
interface that extends `java.rmi.Remote`, the client will receive the 
`java.rmi.RemoteException` instead.] If the
EJB 2.1 client view is used, the container must throw the
java.rmi.RemoteException if the second client is a remote client, or the
_javax.ejb.EJBException_ if the second client is a local client.

There is no need for any restrictions against
concurrent client access to stateless session beans because the
container routes each request to a different instance of the stateless
session bean class.

===== Stateful Session Bean Concurrent Access Timeouts

The AccessTimeout annotation is used to
specify the amount of time a stateful session bean request should block
in the case that it cannot immediately access a bean instance that is
already processing a different request. If an access attempt times out,
the container throws the javax.ejb.ConcurrentAccessTimeoutException to
the client.

The AccessTimeout annotation can be specified
on a business method or on the bean class (or superclass). The
AccessTimeout annotation specified on a class applies the access timeout
to all business methods of that class. If the AccessTimeout annotation
is specified on both the class and on a business method of that class,
the method-level annotation takes precedence.

An AccessTimeout value of -1 indicates that a
concurrent client request will block indefinitely until it can proceed.

==== Transaction Context of Session Bean Methods

The following
session bean methods are invoked in the scope of a transaction
determined by the transaction attribute specified in the bean’s metadata
annotations or deployment descriptor.

An implementation of a method defined in a
session bean’s business interface or component interface or no-interface
view.

A web service method.

A timeout callback method

A singleton session bean’s PostConstruct or
PreDestroy lifecycle callback interceptor method.

A stateful session bean's PostConstruct,
PreDestroy, PrePassivate or PostActivate lifecycle callback interceptor
method is invoked in the scope of a transaction determined by the
transaction attribute specified in the lifecycle callback method's
metadata annotations or deployment descriptor.

A stateful session bean’s _afterBegin_ and
_beforeCompletion_ methods are always called with the same transaction
context as the business methods executed between the _afterBegin_ and
_beforeCompletion_ methods.

A session bean’s _constructor_ ,
_setSessionContext_ , other dependency injection methods, other life
cycle callback interceptor methods, and _afterCompletion_ methods are
called with an unspecified transaction context. Refer to section
link:Ejb.html#a2889[See Handling of Methods that Run with “an
unspecified transaction context”] for how the container executes methods
with an unspecified transaction context.

If database operations are performed within a
stateful session bean’s _PostConstruct_ , _PreDestroy_ , _PrePassivate_
or _PostActivate_ lifecycle callback interceptor methods these
operations will not be part of the client’s transaction. If such a
transaction is rolled back, the instance is discarded. See section
link:Ejb.html#a1041[See Dealing with Exceptions] for rules on
dealing with exceptions in stateful session beans.

[[a800]]
=== Access in the Global JNDI Namespace



The Java EE Platform Specification defines a
standardized global JNDI namespace and a series of related namespaces
that map to the various scopes of a Java EE application. These
namespaces can be used by applications to portably retrieve references
to components and resources. This specification defines the JNDI names
by which session beans are required to be registered within these
namespaces.

==== Syntax

Each portable session bean global JNDI name
has the following syntax:

{empty}java:global[/<app-name>]/<module-name>/<bean-name>[!<fully-qualified-interface-name>]

<app-name> only applies if the session bean
is packaged within an .ear file. It defaults to the base name of the
_.ear_ file with no filename extension, unless specified by the
application.xml deployment descriptor.

<module-name> is the name of the module in
which the session bean is packaged. In a stand-alone ejb-jar file or
.war file, <module-name> defaults to the base name of the module with
any filename extension removed. In an ear file, the <module-name>
defaults to the pathname of the module with any filename extension
removed, but with any directory names included. The default module name
can be overridden using the module-name element of ejb-jar.xml file (for
_ejb-jar_ files) or web.xml file (for _.war_ files).

<bean-name> is the ejb-name of the enterprise
bean. For enterprise beans defined via annotations, it defaults to the
unqualified name of the session bean class, unless otherwise specified
by the _name_ element of the Stateless, Stateful, or Singleton
annotation. For enterprise beans defined via the _ejb-jar.xml_ file, it
is specified in the ejb-name deployment descriptor element.

The container registers a separate JNDI name
entry for each local business interface, each remote business interface,
any no-interface view, any local home interface, and any remote home
interface. For the no-interface view, the last portion of the entry name
is the fully-qualified name of the bean class.

In addition to the previous requirements, if
the bean exposes only one of the applicable client interfaces (or,
alternatively has only a no-interface view), the container registers an
entry for that view with the following syntax:

java:global[/<app-name>]/<module-name>/<bean-name>

{empty}The container is also required to make
session bean JNDI names available through the java:app and java:module
namespaces.footnote:a10239[Note that the existence of global JNDI names 
for the local and no-interface client views does not imply that 
cross-application access to those entries is required. See <<a242>> for 
more details.]

===== java:app

The java:app prefix allows a component
executing within a Java EE application to access an application-specific
namespace. The resulting syntax is:

{empty}java:app/<module-name>/<bean-name>[!<fully-qualified-interface-name>]

Note that <module-name> is a required part of
the syntax, even for names based on session bean components packaged
within a stand-alone module.

[[a816]]
===== java:module

The _java:_ module prefix allows a component
executing within a Java EE application to access a module-specific
namespace. The resulting syntax is:

{empty}java:module/<bean-name>[!<fully-qualified-interface-name>]

==== Examples

The following examples show the resulting
global JNDI names for various session beans.

===== Session bean exposing a single local business interface



package com.acme;



@Stateless

public class FooBean implements Foo \{ ... }



If FooBean is packaged in fooejb.jar without
a deployment descriptor and deployed as a stand-alone module, the
resulting JNDI name entries are:

java:global/fooejb/FooBean

java:global/fooejb/FooBean!com.acme.Foo



java:app/fooejb/FooBean

java:app/fooejb/FooBean!com.acme.Foo



java:module/FooBean

java:module/FooBean!com.acme.Foo

If FooBean is packaged in fooejb.jar within
fooapp.ear, without the use of any deployment descriptors, the resulting
global JNDI name entries are:

java:global/fooapp/fooejb/FooBean

java:global/fooapp/fooejb/FooBean!com.acme.Foo



java:app/fooejb/FooBean

java:app/fooejb/FooBean!com.acme.Foo



java:module/FooBean

java:module/FooBean!com.acme.Foo

If FooBean is packaged in a stand-alone
fooweb.war file, without the use of any deployment descriptors, the
resulting global JNDI name entries are:

java:global/fooweb/FooBean

java:global/fooweb/FooBean!com.acme.Foo



java:app/fooweb/FooBean

java:app/fooweb/FooBean!com.acme.Foo



java:module/FooBean

java:module/FooBean!com.acme.Foo

If FooBean is packaged in fooweb.war within
fooapp.ear, without the use of any deployment descriptors, the resulting
global JNDI name entries are:

java:global/fooapp/fooweb/FooBean

java:global/fooapp/fooweb/FooBean!com.acme.Foo



java:app/fooweb/FooBean

java:app/fooweb/FooBean!com.acme.Foo



java:module/FooBean

java:module/FooBean!com.acme.Foo









===== Session bean exposing multiple client views



package com.acme;



@Singleton(name="Shared")

@LocalBean

@Remote(com.acme.SharedRemote.class)

public class SharedBean \{ ... }



If SharedBean is packaged in shared.jar
without a deployment descriptor and deployed as a stand-alone module,
the resulting global JNDI name entries are:

java:global/shared/Shared!com.acme.SharedBean

java:global/shared/Shared!com.acme.SharedRemote



java:app/shared/Shared!com.acme.SharedBean

java:app/shared/Shared!com.acme.SharedRemote



java:module/Shared!com.acme.SharedBean

java:module/Shared!com.acme.SharedRemote



=== Asynchronous Methods



A session bean can expose methods with
asynchronous client invocation semantics. For asynchronous invocations,
control returns to the client before the container dispatches the
invocation to a bean instance. An asynchronous method is a business
method exposed through one or more of the remote business, local
business, or no-interface session bean views.

Asynchronous methods can return a Future<V>
object that allows the client to retrieve a result value, check for
exceptions, or attempt to cancel an in-progress invocation.

==== Metadata

The Asynchronous annotation is used to
designate which business methods are asynchronous.

The Asynchronous annotation can be applied to
a particular business method of a bean class (or superclass), or to the
bean class (or superclass). If the Asynchronous annotation is applied at
the class level, all business methods declared on that specific class
are asynchronous.

Asynchronous methods can also be designated
via the deployment descriptor.

Asynchronous method invocation semantics only
apply to the no-interface, local business, and remote business client
views. Support for asynchronous business methods exposed through the
local component, remote component, and web service client views is not
required by this specification, and applications which expose such views
with asynchronous methods will not be portable.

==== Method Requirements

The valid return type of an asynchronous
method is either void or java.util.concurrent.Future<V>, where V is the
result value type.

An asynchronous method with return type void
must not declare any application exceptions. An asynchronous method with
return type Future<V> is permitted to declare application exceptions.

===== Return Values

The Bean Provider makes the result value of
an asynchronous invocation available to the client by returning a
Future<V> object for which both get() methods return the result value. A
concrete Future<V> implemention called javax.ejb.AsyncResult<V> is
provided by the container as a convenience. The AsyncResult<V> class has
a constructor that takes the result value as a parameter.

Example:

@Asynchronous

public Future<Integer>
performCalculation(...) \{



 // ... do calculation



 Integer result = ...;



 return new AsyncResult<Integer>(result);

}

Note that the Future<V> object returned from
the bean class method (including any instance of AsyncResult<V>) is only
used as a way to pass the result value to the container. This object is
not given directly to the caller, since by definition the caller already
has a container-generated Future<V> object that was returned from the
original invocation.

===== Method cancellation

A client can request that an asynchronous
invocation be cancelled by calling the Future<V>.cancel(boolean
mayInterruptIfRunning) method. The Bean Provider can check whether the
client has requested cancellation by calling the
SessionContext.wasCancelCalled() method within the context of the
asynchronous method. See link:Ejb.html#a387[See Asynchronous
Invocations] for the description of the client Future contract.

==== Transactions

The client’s transaction context does not
propagate with an asynchronous method invocation. From the Bean
Provider’s point of view, there is never a transaction context flowing
in from the client. This means, for example, that the semantics of the
REQUIRED transaction attribute on an asynchronous method are exactly the
same as REQUIRES_NEW.

==== Security

The caller security principal propagates with
an asynchronous method invocation. Caller security principal propagation
behaves exactly the same for asynchronous method invocations as it does
for synchronous session bean invocations.

==== Client Exception Behavior

Client exception behavior depends on whether
the asynchronous method has return type void or Future<V>.

If the asynchronous method has return type
void, then once control has returned from the client’s method call no
exceptions occurring during the processing of the invocation will be
delivered to the client. For this reason, asynchronous methods with
return type void must not declare application exceptions.

If the asynchronous method has return type
Future<V>, an exception thrown from the processing of the asynchronous
method invocation is accessible to the client via the getCause() method
of a java.util.concurrent.ExecutionException thrown from either
Future.get() method.

[[a921]]
=== Stateful Session Beans



==== Stateful Session Bean Lifecycle State Diagram

The following figure illustrates the life
cycle of a stateful session bean instance.

===



Life Cycle of a Stateful Session Bean Instance

image:EBCore-10.png[image]

The following
steps describe the life cycle of a stateful session bean instance:

A session bean instance’s life starts when a
client obtains a reference to a stateful session bean instance through
dependency injection or JNDI lookup, or when the client invokes a
_create<METHOD>_ method on the session bean’s home interface. This
causes the container to invoke the session bean class constructor to
create a new session bean instance.footnote:a10240[If an `AroundConstruct` 
lifecycle callback interceptor is associated with the stateful session bean, 
the container follows the rules for the `AroundConstruct` interceptors 
defined in the _Interceptors_ specification <<a9887>>.] Next, the
container performs any dependency injection as specified by metadata
annotations on the bean class or by the deployment descriptor. The
container then calls the _PostConstruct_ lifecycle callback interceptor
method(s) for the bean, if any. Finally, if the session bean was written
to the EJB 2.1 client view, the container invokes the matching
_ejbCreate<METHOD>_ or _Init_ method on the instance. The container then
returns the session object reference to the client. The instance is now
in the method ready state.

 _NOTE: When a stateful session bean is
looked up or otherwise obtained through the explicit JNDI lookup
mechanisms, the container must provide a new stateful session bean
instance, as required by the Java EE specification (Section “Java Naming
and Directory Interface (JNDI) Naming Context”
link:Ejb.html#a9854[See Java™ Naming and Directory Interface 1.2
Specification (JNDI).
http://docs.oracle.com/javase/7/docs/technotes/guides/jndi/index.html.])._

The session bean instance is now ready for
client’s business methods. Based on the transaction attributes in the
session bean’s metadata annotations and/or deployment descriptor and the
transaction context associated with the client’s invocation, a business
method is executed either in a transaction context or with an
unspecified transaction context (shown as “tx method” and “non-tx
method” in the diagram). See link:Ejb.html#a2172[See Support for
Transactions] for how the container deals with transactions.

A non-transactional method is executed while
the instance is in the method ready state.

An invocation of a transactional method
causes the instance to be included in a transaction. When the session
bean instance is included in a transaction, the container issues the
_afterBegin_ method on it if the session bean has an _afterBegin_
callback method.footnote:a10241[If a stateful session bean lifecycle 
callback interceptor method is invoked in the scope of a transaction, 
session synchronization callbacks for such transactions are not called 
on the bean instance — see <<a2750>>.] The _afterBegin_ method is
invoked on the instance before any business method or business method
interceptor method is executed as part of the transaction. The instance
becomes associated with the transaction and will remain associated with
the transaction until the transaction completes.

Session bean methods invoked by the client in
this transaction can now be delegated to the bean instance. An error
occurs if a client attempts to invoke a method on the session object and
the bean’s metadata annotations and/or deployment descriptor for the
method requires that the container invoke the method in a different
transaction context than the one with which the instance is currently
associated or in an unspecified transaction context.

If a transaction commit has been requested,
the transaction service notifies the container of the commit request
before actually committing the transaction, and the container issues the
_befor_ _eCompletion_ callback on the instance if the session bean has a
_beforeCompletion_ callback method.footnote:a10241[] When _beforeCompletion_ 
is invoked, the instance should write
any cached updates to the database.footnote:a10242[Note that if the Java 
Persistence API is used, the persistence provider will use the 
beforeCompletion notification to automatically flush any updates to the 
container-managed persistence context to the database. See <<a9851>>.] If a
transaction rollback had been requested instead, the rollback status is
reached without the container issuing a _beforeCompletion_ . The
container may not call the _beforeCompletion_ method if the transaction
has been marked for rollback (nor does the instance write any cached
updates to the database).

The transaction service then attempts to
commit the transaction, resulting in either a commit or rollback.

When the transaction completes, the container
issues _afterCompletion_ on the instance if the session bean has an
_afterCompletion_ callback method,footnote:a10241[] specifying the status of the completion (either commit or
rollback). If a rollback occurred, the bean instance may need to reset
its conversational state back to the value it had at the beginning of
the transaction.

The container’s caching algorithm may decide
that the bean instance should be evicted from memory. (This could be
done at the end of each method, or by using an LRU policy). The
container invokes the _PrePassivate_ lifecycle callback interceptor
method(s) for the bean instance, if any. After this completes, the
container saves the instance’s state to secondary storage. A session
bean can be passivated only between transactions, and not within a
transaction.

While the instance is in the
passivated state, the container may remove
the session object after the expiration of a
timeout specified by the Deployer. All
object references and handles for the session object become invalid. If
a client attempts to invoke a method on the bean’s business interface,
the container will throw the
_javax.ejb.NoSuchEJBException_.footnote:a10243[If the business interface 
is a remote business interface that extends `java.rmi.Remote`, 
the `java.rmi.NoSuchObjectException` is thrown to the client instead.] 
If the EJB 2.1
client view is used, the container will throw the
java.rmi.NoSuchObjectException if the client is a remote client, or the
_javax.ejb.NoSuchObjectLocalException_ if the client is a local client.

If a client invokes a session object whose
session bean instance has been passivated, the container will activate
the instance. To activate the session bean instance, the container
restores the instance’s state from secondary storage and invokes the
_PostActivate_ method for the instance, if any.

The session bean instance is again ready for
client methods.

When the client calls a business method of
the bean that has been designated as a _Remove_ method on the bean class
or a _remove_ method on the home or component interface, the container
invokes _PreDestroy_ lifecycle callback interceptor methods, if any, for
the bean instance after the _Remove_ method
completes.footnote:a10244[If the `Remove` annotation specifies the value 
of `retainIfException` as `true`, and the `Remove` method throws an 
application exception, the instance is not removed (and the `PreDestroy` 
lifecycle callback interceptor methods are not invoked).] 
This ends the life of the session bean
instance and the associated session object. If a client subsequently
attempts to invoke a method on the bean’s business interface, the
container will throw the
_javax.ejb.NoSuchEJBException_.footnote:a10245[If the business interface 
is a remote business interface that extends `java.rmi.Remote`, the 
`java.rmi.NoSuchObjectException` is thrown to the client instead.] 
If the EJB 2.1
client view is used, any subsequent attempt causes the
_java.rmi.NoSuchObjectException_ to be thrown if the client is a remote
client, or the _javax.ejb.NoSuchObjectLocalException_ if the client is a
local client. (The _java.rmi.NoSuchObjectException_ is a subclass of the
_java.rmi.RemoteException_ ; the _javax.ejb.NoSuchObjectLocalException_
is a subclass of the _javax.ejb.EJBException_ ). If the _Remove_ method
completes successfully or if the _Remove_ method throws an application
exception for which _retainIfException_ is not _true_ or if a system
exception is thrown, session synchronization methods are not called on
the bean instance. If an application exception is thrown for which
_retainIfException_ is _true_ , the bean is neither destroyed nor
discarded, and session synchronization methods, if any, are called on
the instance at the end of transaction _._ A container can also invoke
the _PreDestroy_ method on the instance without a client call to remove
the session object:

After the lifetime of the EJB object has
expired

When the CDI context, to which the EJB object
belongs to, is destroyed.

The container must call the afterBegin,
beforeCompletion, and afterCompletion methods if the session bean class
implements, directly or indirectly, the SessionSynchronization
interface, or if the bean class uses the session synchronization
annotations.

[[a947]]
==== Operations Allowed in the Methods of a Stateful Session Bean Class

Table link:Ejb.html#a953[See
Operations Allowed in the Methods of a Stateful Session Bean] defines
the methods of a stateful session bean class from which the session bean
instances can access the methods of the javax.ejb.SessionContext
interface, the java:comp/env environment naming context, resource
managers, _Timer_ methods, the _EntityManager_ and
_EntityManagerFactory_ methods, and other enterprise beans.

If a session bean
instance attempts to invoke a method of the SessionContext interface,
and that access is not allowed in Table link:Ejb.html#a953[See
Operations Allowed in the Methods of a Stateful Session Bean], the
container must throw the java.lang.IllegalStateException.

If a session bean instance attempts to access
a resource manager, an enterprise bean, an entity manager or entity
manager factory, and that access is not allowed in Table
link:Ejb.html#a953[See Operations Allowed in the Methods of a
Stateful Session Bean], the behavior is undefined by the EJB
architecture.

If a session bean instance attempts to invoke
a method of the _Timer_ interface and the access is not allowed in Table
link:Ejb.html#a953[See Operations Allowed in the Methods of a
Stateful Session Bean], the container must throw the
_java.lang.IllegalStateException_ .

===



[[a953]]Operations Allowed in the Methods of a Stateful
Session Bean

Bean method





Bean method can perform the following
operations



Container-managed transaction demarcation

Bean-managed transaction demarcation

constructor

-

-

dependency injection methods (e.g.,
setSessionContext)

SessionContext methods: getEJBHome,
getEJBLocalHome, lookup

JNDI access to java:comp/env

SessionContext methods: getEJBHome,
getEJBLocalHome, lookup

JNDI access to java:comp/env

PostConstruct, PreDestroy,
PrePassivate, PostActivate lifecycle callback interceptor
methods footnote:a10246[If a client calls lifecycle callback method 
through a business interface or a no-interface view, the method is 
treated like a business method.]

SessionContext methods: _getBusinessObject_ ,
getEJBHome, _getEJBLocalHome_ , getRollbackOnly, setRollbackOnly,
getCallerPrincipal, isCallerInRole, getEJBObject, getEJBLocalObject,
lookup, getContextData

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

SessionContext methods: _getBusinessObject_ ,
getEJBHome, _getEJBLocalHome_ , getCallerPrincipal, isCallerInRole,
getEJBObject, getEJBLocalObject, getUserTransaction, lookup,
getContextData

UserTransaction methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access





business method

from business interface or from no-interface
view or from component interface;

business method interceptor method

SessionContext methods: _getBusinessObject_ ,
getEJBHome, _getEJBLocalHome_ , getCallerPrincipal, getRollbackOnly,
isCallerInRole, setRollbackOnly, getEJBObject, getEJBLocalObject,
getInvokedBusinessInterface, wasCancelCalled, lookup, getContextData



JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

Timer methods

SessionContext methods: _getBusinessObject_ ,
getEJBHome, _getEJBLocalHome_ , getCallerPrincipal, isCallerInRole,
getEJBObject, getEJBLocalObject, getInvokedBusinessInterface,
wasCancelCalled, getUserTransaction, lookup, getContextData

UserTransaction methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

Timer methods

afterBegin

beforeCompletion

SessionContext methods: _getBusinessObject_ ,
getEJBHome, _getEJBLocalHome,_ getCallerPrincipal, getRollbackOnly,
isCallerInRole, setRollbackOnly, getEJBObject, getEJBLocalObject,
lookup, getContextData

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

Timer methods









N/A

(a bean with bean-managed transaction
demarcation cannot implement the SessionSynchronization interface or use
the session synchronization annotations)

afterCompletion

SessionContext methods: _getBusinessObject_ ,
getEJBHome, _getEJBLocalHome,_ getCallerPrincipal, isCallerInRole,
getEJBObject, getEJBLocalObject, lookup, getContextData

JNDI access to java:comp/env

Notes:

The _PostConstruct_ , _PreDestroy_ ,
_PrePassivate_ , _PostActivate_ , and/or ejbCreate _<METHOD>_ ,
ejbRemove, ejbPassivate, and ejbActivate methods of a stateful session
bean with container-managed transaction demarcation are invoked in the
scope of a transaction determined by the
transaction attribute specified in the
bean’s metadata annotations or deployment descriptor.

The _Init methods of a session bean with
container-managed transaction demarcation execute with an unspecified
transaction context._ Refer to Subsection
link:Ejb.html#a2889[See Handling of Methods that Run with “an
unspecified transaction context”] for how the container executes methods
with an unspecified transaction context _._

In some cases, lifecycle callback interceptor
methods initiated solely by the container without an associated client
invocation run in an unspecified security context, e.g., a PostConstruct
method callback invoked as a side-effect of the injection of a remote or
local business interface reference. However, the container is still
required to permit client calls to these methods according to the rules
in this table (see note on link:Ejb.html#a1516[See Note:
Callback methods are permitted to have public access type. This raises
the question of whether a callback method can also be exposed as a
business method through one or more client views. Doing so is not
prohibited, but should be done with caution. The runtime context (e.g.
transaction context, caller principal, operations allowed, etc.) for a
method invoked as a callback can differ significantly from the context
for the same method when invoked via a client invocation. As a general
rule, callback methods should not be exposed as business methods.
Therefore, it is recommended that all non-business methods be assigned
an access type other than public.]).

Additional restrictions:

The getRollbackOnly and setRollbackOnly
methods of the SessionContext interface should be used only in the
session bean methods that execute in the context of a transaction. The
container must throw the java.lang.IllegalStateException if the methods
are invoked while the instance is not associated with a transaction.

The reasons for disallowing the operations in
Table link:Ejb.html#a953[See Operations Allowed in the Methods
of a Stateful Session Bean] follow:

Invoking the _getBusinessObject_ method is
disallowed if the session bean does not define a business interface or a
no-interface view.

Invoking the _getInvokedBusinessInterface_
method is disallowed if the session bean does not define a business
interface or a no-interface view. It is also disallowed if the current
business method was not invoked through a business interface or the
no-interface view.

Invoking the _getEJBObject_ and _getEJBHome_
methods is disallowed if the session bean does not define a remote
component client view.

Invoking the _getEJBLocalObject_ and
_getEJBLocalHome_ methods is disallowed if the session bean does not
define a local component client view.

Invoking the getRollbackOnly and
setRollbackOnly methods is disallowed in the session bean methods for
which the container does not have a meaningful transaction context, and
to all session beans with bean-managed transaction demarcation.

Accessing resource managers and enterprise
beans is disallowed in the session bean methods for which the container
does not have a meaningful transaction context and/or client security
context.

The UserTransaction interface is unavailable
to enterprise beans with container-managed transaction demarcation.

The _TimerService_ interface is unavailable
to stateful session beans.

Invoking the _getMessageContext_ method is
disallowed for stateful session beans.

Invoking the getEJBObject and
_getEJBLocalObject_ methods is disallowed in the session bean methods in
which there is no session object identity established for the instance.

Invoking the _wasCancelCalled_ method is
disallowed except when inside the context of the asynchronous methods
that declare Future<V> object as the returning type.

[[a1041]]
==== Dealing with Exceptions

A
RuntimeException that is not an application
exception thrown from any method of the stateful session bean class
(including the business methods and the lifecycle callback interceptor
methods invoked by the container) results in the transition to the “does
not exist” state. Exception handling is described in detail in Chapter
link:Ejb.html#a2940[See Exception Handling]. See the
_Interceptors_ specification link:Ejb.html#a9887[See
Interceptors, version 1.2. http://jcp.org/en/jsr/detail?id=318.] for the
rules pertaining to lifecycle callback interceptor methods when more
than one such method applies to the bean class.

From the client perspective, the
corresponding session object does not exist any more. If a client
subsequently attempts to invoke a method on the bean’s business
interface or the no-interface view, the container will throw the
_javax.ejb.NoSuchEJBException_.footnote:a10247[If the business interface is 
a remote business interface that extends `java.rmi.Remote`, the 
`java.rmi.NoSuchObjectException` is thrown to the client instead.] 
If the EJB 2.1
client view is used, the container will throw the
java.rmi.NoSuchObjectException if the client is a remote client, or the
_javax.ejb.NoSuchObjectLocalException_ if the client is a local client.

==== Missed `PreDestroy` Calls

The Bean Provider
cannot assume that the container will always invoke the PreDestroy
lifecycle callback interceptor method(s) (or _ejbRemove_ method) for a
stateful session bean instance. The following scenarios result in the
PreDestroy lifecycle callback interceptor method(s) not being called for
an instance:

A crash of the
EJB container.

A system
exception thrown from the instance’s method to the container.

A timeout of
client inactivity while the instance is in the passive state. The
timeout is specified by the Deployer in an EJB container
implementation-specific way.

If resources are allocated in a
_PostConstruct_ lifecycle callback interceptor method (or
ejbCreate<METHOD> method) and/or in the business methods, and normally
released in a PreDestroy lifecycle callback interceptor method, these
resources will not be automatically released in the above scenarios. The
application using the stateful session bean should provide some clean up
mechanism to periodically clean up the unreleased resources.

For example, if a shopping cart component is
implemented as a session bean, and the session bean stores the shopping
cart content in a database, the application should provide a program
that runs periodically and removes “abandoned” shopping carts from the
database.

[[a1053]]
==== Disabling Passivation of Stateful Session Beans

By default, the container may passivate a
stateful session bean instance to a secondary storage to save resources.
However, the Bean Provider can optionally configure the stateful session
bean to prevent passivation of its instances.

For example, a stateful session bean instance
may contain non-serializable attributes which would lead to runtime
exceptions during passivation, or passivation and activation of such
instances may cause degradation of application performance.

If the passivationCapable element of the
Stateful annotation is set to false or the passivation-capable element
of the session deployment descriptor element is set to false, the
container must not attempt to passivate instances of the bean.

Note: application server vendors may use
passivation as a technique to provide high availability of stateful
session beans by replicating their state from one JVM instance to
another across which the container is distributed. In a failure
situation, a stateful session bean is made available on a new JVM
instance by what is commonly called stateful session bean failover. If a
container implementation supports failover of stateful session beans
using bean passivation, the failover capability for not passivation
capable stateful session beans is not defined.

==== Transaction Semantics of Initialization, Destruction, Activation and Passivation

By default a stateful session bean’s
_PostConstruct_ , _PreDestroy_ , _PrePassivate_ and _PostActivate_
methods are executed in an unspecified transactional context. A
_PostConstruct_ , _PreDestroy_ , _PrePassivate_ and _PostActivate_
method of a stateful session bean with container-managed transaction
demarcation is permitted to have transaction attribute REQUIRES_NEW or
NOT_SUPPORTED (RequiresNew or NotSupported if the deployment descriptor
is used to specify the transaction attribute).

==== Restrictions for Transactions

The state diagram
implies the following restrictions on transaction scoping of the client
invoked business methods. The restrictions are enforced by the container
and must be observed by the client programmer.

A stateful session bean instance can
participate in at most a single transaction at a time.

If a stateful session bean instance is
participating in a transaction, it is an error for a client to invoke a
method on the session object such that the transaction attribute
specified in the bean’s metadata annotations and/or the deployment
descriptor would cause the container to execute the method in a
different transaction context or in an unspecified transaction context.
In such a case, the _javax.ejb.EJBException_ will be thrown to a client
of the bean’s business interface.footnote:a10248[If the business interface 
is a remote business interface that extends `java.rmi.Remote`, the 
`java.rmi.RemoteException` is thrown to the client instead.] 
If the EJB 2.1
client view is used, the container throws the _java.rmi.RemoteException_
to the client if the client is a remote client, or the
_javax.ejb.EJBException_ if the client is a local client.

If a stateful session bean instance is
participating in a transaction, it is an error for a client to invoke
the _remove_ method on the session object’s home or component interface
object. The container must detect such an attempt and throw the
_javax.ejb.RemoveException_ to the client. The container should not mark
the client’s transaction for rollback, thus allowing the client to
recover. Note that this restriction only applies to the remove method on
the session object’s home or component interface, not to the invocation
of Remove methods.

[[a1065]]
=== Stateless Session Beans



Stateless session
beans are session beans whose instances have no conversational state.
This means that all bean instances are equivalent when they are not
involved in servicing a client-invoked method.

The term “stateless” signifies that an
instance has no state for a specific client. However, the instance
variables of the instance can contain the state across client-invoked
method calls. Examples of such state include an open database connection
and an object reference to an enterprise bean object.

The Bean Provider must exercise caution if
retaining any application state across method calls. In particular,
references to bean instance variables should not be returned through
multiple local interface method calls.

Because all instances of a stateless session
bean are equivalent, the container can choose to delegate a
client-invoked method to any available instance. This means, for
example, that the container may delegate the requests from the same
client within the same transaction to different instances, and that the
container may interleave requests from multiple transactions to the same
instance.

A container only
needs to retain the number of instances required to service the current
client load. Due to client “think time,” this number is typically much
smaller than the number of active clients. Passivation is not needed or
used for stateless session beans. The container creates another
stateless session bean instance if one is needed to handle an increase
in client work load. If a stateless session bean is not needed to handle
the current client work load, the container can destroy it.

Because stateless session beans minimize the
resources needed to support a large population of clients, depending on
the implementation of the container, applications that use stateless
session beans may scale somewhat better than those using stateful
session beans. However, this benefit may be offset by the increased
complexity of the client application that uses the stateless beans.

There is no fixed mapping between clients and
stateless instances. The container simply delegates a client’s work to
any available instance that is method-ready.

Local and remote
clients using the EJB 2.1 client view interfaces use the create and
remove methods on the home interface of a stateless session bean in the
same way as on a stateful session bean. To the EJB 2.1 client, it
appears as if the client controls the life cycle of the session object.
However, the container handles the create and remove calls without
necessarily creating and removing an EJB instance.
The home interface of a stateless session
bean must have one create method that takes no arguments. The _create_
method of the remote home interface must return the session bean’s
remote interface. The _create_ method of the local home interface must
return the session bean’s local interface.
There can be no other _create_ methods in
the home interface.

A stateless session bean must not implement
the javax.ejb.SessionSynchronization interface or use the session
synchronization annotations.

[[a1077]]
==== Stateless Session Bean Lifecycle State Diagram

When a client calls a method on a stateless
session object or invokes a method on a stateless session bean through
its web service client view, the container selects one of its
method-ready __ instances and delegates the method invocation to it.

The following figure illustrates the life
cycle of a stateless session bean instance.

===



Life Cycle of a Stateless Session Bean

image:EBCore-11.png[image]

The following steps describe the life cycle
of a stateless session bean instance:

A stateless session bean instance’s life
starts when the container invokes the session bean class constructor to
create a new session bean instance.footnote:a10249[If an `AroundConstruct` 
lifecycle callback interceptor is associated with the stateless session 
bean, the container follows the rules for the `AroundConstruct` 
interceptors defined in the _Interceptors_ specification <<a9887>>.] 
Next, the
container performs any dependency injection as specified by metadata
annotations on the bean class or by the deployment descriptor. The
container then calls the _PostConstruct_ lifecycle callback interceptor
methods for the bean, if any. The container can perform the instance
creation at any time—there is no direct relationship to a client’s
invocation of a business method or the _create_ method.

The session bean instance is now ready to be
delegated a business method call from any client or a call from the
container to a timeout callback method.

When the container no longer needs the
instance (usually when the container wants to reduce the number of
instances in the method-ready pool), the container invokes the
_PreDestroy_ lifecycle callback interceptor methods for it, if any. This
ends the life of the stateless session bean instance.

[[a1085]]
==== Operations Allowed in the Methods of a Stateless Session Bean Class

Table link:Ejb.html#a1091[See
Operations Allowed in the Methods of a Stateless Session Bean] defines
the methods of a stateless session bean class in which the session bean
instances can access the methods of the javax.ejb.SessionContext
interface, the java:comp/env environment naming context, resource
managers, _TimerService_ and _Timer_ methods, the _EntityManager_ and
_EntityManagerFactory_ methods, and other enterprise beans.

If a session bean instance attempts to invoke
a method of the SessionContext interface, and the access is not allowed
in Table link:Ejb.html#a1091[See Operations Allowed in the
Methods of a Stateless Session Bean], the container must throw the
java.lang.IllegalStateException.

If a session bean instance attempts to invoke
a method of the _TimerService_ or _Timer_ interface and the access is
not allowed in Table link:Ejb.html#a1091[See Operations Allowed
in the Methods of a Stateless Session Bean], the container must throw
the _java.lang.IllegalStateException_ .

If a session bean instance attempts to access
a resource manager, an enterprise bean, an entity manager or entity
manager factory, and the access is not allowed in Table
link:Ejb.html#a1091[See Operations Allowed in the Methods of a
Stateless Session Bean], the behavior is undefined by the EJB
architecture.

===



[[a1091]]Operations Allowed in the Methods of a Stateless
Session Bean

Bean method





Bean method can perform the following
operations



Container-managed transaction demarcation

Bean-managed transaction demarcation

constructor

-

-

dependency injectionmethods (e.g.,
setSessionContext)

SessionContext methods: getEJBHome,
getEJBLocalHome, lookup

JNDI access to java:comp/env

SessionContext methods: getEJBHome,
getEJBLocalHome, lookup

JNDI access to java:comp/env

PostConstruct, PreDestroy lifecycle
callback interceptor methods footnote:a10250[If a client calls lifecycle 
callback method through a business interface or a no-interface view, 
the method is treated like a business method.]

SessionContext methods: _getBusinessObject,_
getEJBHome, getEJBLocalHome, getEJBObject, getEJBLocalObject,
getTimerService, lookup, getContextData

JNDI access to java:comp/env

EntityManagerFactory access

SessionContext methods: _getBusinessObject,_
getEJBHome, getEJBLocalHome, getEJBObject, getEJBLocalObject,
getUserTransaction, getTimerService, lookup, getContextData

JNDI access to java:comp/env

EntityManagerFactory access

business method

from business interface or from no-interface
view or from component interface; business method interceptor method

SessionContext methods: _getBusinessObject_ ,
getEJBHome, getEJBLocalHome, getCallerPrincipal, isCallerInRole,
getRollbackOnly, setRollbackOnly, getEJBObject, getEJBLocalObject,
getTimerService, getInvokedBusinessInterface, wasCancelCalled, lookup,
getContextData

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

SessionContext methods: _getBusinessObject,_
getEJBHome, getEJBLocalHome, getCallerPrincipal, isCallerInRole,
getEJBObject, getEJBLocalObject, getUserTransaction, getTimerService,
getInvokedBusinessInterface, wasCancelCalled, lookup, getContextData

UserTransaction methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

business method

from web service endpoint

SessionContext methods: _getBusinessObject,_
getEJBHome, getEJBLocalHome, getCallerPrincipal, isCallerInRole,
getRollbackOnly, setRollbackOnly, getEJBObject, getEJBLocalObject,
getTimerService, getMessageContext, lookup, getContextData

Message context methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

SessionContext methods: _getBusinessObject,_
getEJBHome, getEJBLocalHome, getCallerPrincipal, isCallerInRole,
getEJBObject, getEJBLocalObject, getUserTransaction, getTimerService,
getMessageContext, lookup, getContextData

UserTransaction methods

Message context methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

timeout callback method

SessionContext methods: _getBusinessObject,_
getEJBHome, getEJBLocalHome, getCallerPrincipal, isCallerInRole,
getRollbackOnly, setRollbackOnly, getEJBObject, getEJBLocalObject,
getTimerService, lookup, getContextData

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

SessionContext methods: _getBusinessObject,_
getEJBHome, getEJBLocalHome, getCallerPrincipal, isCallerInRole,
getEJBObject, getEJBLocalObject, getUserTransaction, getTimerService,
lookup, getContextData

UserTransaction methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

Additional restrictions:

The getRollbackOnly and setRollbackOnly
methods of the SessionContext interface should be used only in the
session bean methods that execute in the context of a transaction. The
container must throw the java.lang.IllegalStateException if the methods
are invoked while the instance is not associated with a transaction.

The reasons for disallowing operations in
Table link:Ejb.html#a1091[See Operations Allowed in the Methods
of a Stateless Session Bean]:

Invoking the _getBusinessObject_ method is
disallowed if the session bean does not define a business interface or a
no-interface view.

Invoking the _getInvokedBusinessInterface_
method is disallowed if the session bean does not define a business
interface or a no-interface view. It is also disallowed if the current
business method was not invoked through a business interface or the
no-interface view.

Invoking the _getEJBObject_ and _getEJBHome_
methods is disallowed if the session bean does not define a
remote component client view.

Invoking the _getEJBLocalObject_ and
_getEJBLocalHome_ methods is disallowed if the session bean does not
define a local component client view.

Invoking the getRollbackOnly and
setRollbackOnly methods is disallowed in the session bean methods for
which the container does not have a meaningful
transaction context, and for all session
beans with bean-managed transaction
demarcation.

Invoking the _getMessageContext_ method is
disallowed in session bean methods that were not invoked by the
container through the session bean’s web service endpoint.

Accessing resource managers, enterprise
beans, and the EntityManager is disallowed in the session bean methods
for which the container does not have a meaningful transaction context
and/or client security context.

The UserTransaction interface is unavailable
to session beans with container-managed
transaction demarcation.

Invoking the _wasCancelCalled_ method is
disallowed except when inside the context of the asynchronous methods
that declare Future<V> object as the returning type.

==== Dealing with Exceptions

A
RuntimeException that is not an application exception thrown from any
method of the enterprise bean class (including the business methods and
the lifecycle callback interceptor methods invoked by the container)
results in the transition to the “does not exist” state. Exception
handling is described in detail in Chapter
link:Ejb.html#a2940[See Exception Handling]. See the
_Interceptors_ specification link:Ejb.html#a9887[See
Interceptors, version 1.2. http://jcp.org/en/jsr/detail?id=318.] for the
rules pertaining to lifecycle callback interceptor methods when more
than one such method applies to the bean class.

From the client perspective, the session
object continues to exist. The client can continue accessing the session
object because the container can delegate the client’s requests to
another instance.

=== Singleton Session Beans



A singleton session bean is a session bean
component that is instantiated once per application. In cases where the
container is distributed over many virtual machines, each application
will have one bean instance of the singleton for each JVM.

Once instantiated, a singleton session bean
instance lives for the duration of the application in which it is
created. It maintains its state between client invocations but its state
is not required to survive container shutdown or crash.

A singleton session bean is intended to be
shared, and it supports concurrent access.

A singleton session bean must not implement
the javax.ejb.SessionSynchronization interface or use the session
synchronization annotations.

===



Life Cycle of a Singleton Session Bean

image:EBCore-12.png[image]

The following steps describe the life cycle
of a singleton session bean instance:

A singleton session bean instance’s life
starts when the container invokes the session bean class constructor to
create the singleton bean instance.footnote:a10251[If an `AroundConstruct` 
lifecycle callback interceptor is associated with the singleton session 
bean, the container follows the rules for the `AroundConstruct` 
interceptors defined in the _Interceptors_ specification <<a9887>>.] 
Next, the
container performs any dependency injection as specified by the metadata
annotations on the bean class or by the deployment descriptor. The
container then calls the _PostConstruct_ lifecycle callback interceptor
methods for the bean, if any.

The singleton bean instance is now ready to
be delegated a business method call from any client or a call from the
container to a timeout callback method.

When the application is shutting down, the
container invokes the _PreDestroy_ lifecycle callback interceptor
methods on the singleton session bean instance, if any. This ends the
life of the singleton session bean instance.

==== Singleton Session Bean Initialization

By default, the container is responsible for
deciding when to initialize a singleton session bean instance. However,
the Bean Provider can optionally configure the singleton session bean
for eager initialization. If the Startup annotation appears on the
singleton session bean class or if the singleton session bean has been
designated via the deployment descriptor as requiring eager
initialization, the container must initialize the singleton session bean
instance during the application startup sequence. The container must
initialize all such startup-time singleton session beans before any
external client requests (that is, client requests originating outside
of the application) are delivered to any enterprise bean components in
the application.

The following example shows a singleton
session bean with startup logic that initializes its shared state:

@Startup

@Singleton

public class SharedBean implements Shared \{



 private SharedData state;



 @PostConstruct

 void init() \{

 // initialize shared data

 ...

 }



 ...

}

In some cases, explicit initialization
ordering dependencies exist between multiple singleton session bean
components in an application. The DependsOn annotation is used to
express these dependencies. A DependsOn dependency is used in cases
where one singleton session bean must initialize before one or more
other singleton session beans. The container ensures that all singleton
session beans with which a singleton session bean has a DependsOn
relationship have been initialized before the PostConstruct method is
called.

Note that if one singleton session bean
merely needs to invoke another singleton session bean from its
PostConstruct method, no explicit ordering metadata is required. In that
case, the first singleton session bean would merely use an EJB reference
to invoke the target singleton session bean. In this case, the
acquisition of the EJB reference (either through injection or lookup)
does not necessarily imply the actual creation of the corresponding
singleton session bean instance.

The following examples illustrate the use of
DependsOn metadata:

@Singleton

public class B \{ ... }



@DependsOn("B")

@Singleton

public class A \{ ... }



In the above example, the container must
guarantee that singleton _B_ is initialized before singleton _A_ . The
DependsOn value attribute holds one or more strings, where each
specifies the ejb-name of the target singleton session bean.

In the following example, the container must
guarantee that singletons _B_ and _C_ are initialized before singleton
_A_ . In the case of multiple values, the ordering in which the target
ejb-name values are listed is not preserved at runtime. For example, if
singleton _B_ has an ordering dependency on singleton _C_ , it is
singleton _B_ ’s responsibility to explicitly capture that in its own
metadata.

@Singleton

public class B \{ ... }



@Singleton(name="Cbean")

public class C \{ ... }



@DependsOn(\{"B", "Cbean"})

@Singleton

public class A \{ ... }



The following example illustrates the use of
the fully-qualified ejb-name syntax to refer to a singleton session bean
packaged within a different module in the same application.

// two Singleton components packaged in
different ejb-jars within

// the same .ear



// packaged in b.jar

@Singleton

public class B \{ ... }



// packaged in a.jar

@DependsOn("b.jar#B")

@Singleton

public class A \{ ... }

Circular dependencies within the _DependsOn_
metadata are not permitted. Circular dependencies are not required to be
detected by the container but may result in a deployment error.

==== Singleton Session Bean Destruction

Any singleton session bean instance that
successfully completes initialization is removed by the container during
application shutdown. At this time the container must invoke the
PreDestroy lifecycle callback interceptor methods on the singleton
session bean instance, if any. The container ensures that all singleton
session beans with which a singleton session bean has a DependsOn
relationship are still available during the PreDestroy callback. After
the _PreDestroy_ callback completes, the container ends the life of the
singleton session bean instance.

==== Transaction Semantics of Initialization and Destruction

The _PostConstruct_ and _PreDestroy_ methods
of singleton session beans with container-managed transaction
demarcation can be invoked with or without a transaction. From the Bean
Provider’s view there is no client of a _PostConstruct_ or _PreDestroy_
method.

A _PostConstruct_ or _PreDestroy_ method of a
singleton session bean with container-managed transaction demarcation is
permitted to have transaction attribute _REQUIRED_ , _REQUIRES_NEW_ , or
_NOT_SUPPORTED_ ( _Required_ , _RequiresNew_ , or _NotSupported_ if the
deployment descriptor is used to specify the transaction attribute).

 _Note that the container must start a new
transaction if the_ _REQUIRED_ _(_ _Required_ _)_ _transaction attribute
is used. This guarantees, for example, that the transactional behavior
of the_ _PostConstruct_ _method is the same regardless of whether the
singleton session bean instance is initialized eagerly at container
startup time or as a side effect of a first client invocation on the
singleton session bean._ The REQUIRED transaction attribute value is
allowed so that specification of a transaction attribute for the
_singleton session bean’s_ _PostConstruct_ _and_ _PreDestroy_ _methods_
can be defaulted.

[[a1254]]
==== Singleton Session Bean Error Handling

Errors occurring during singleton session
bean initialization are considered fatal and must result in the
discarding of the singleton session bean instance. Possible
initialization errors include injection failure, a system exception
thrown from an AroundConstruct or PostConstruct method, or the failure
of a PostConstruct method’s container-managed transaction to
successfully commit. If a singleton session bean fails to initialize,
attempted invocations on the singleton session bean result in the
javax.ejb.NoSuchEJBException exception as defined by
link:Ejb.html#a304[See Session Bean’s Business Interface] and
link:Ejb.html#a312[See Session Bean’s No-Interface View] .

The same singleton session bean instance must
remain active until application shutdown. Unlike instances of other
component types, system exceptions thrown from business methods or
callbacks of a singleton session bean do not result in the destruction
of the singleton instance.

[[a1257]]
==== Singleton Session Bean Concurrency

From the client’s perspective, a singleton
session bean always supports concurrent access. In general, the client
of a singleton session bean does not have to concern itself with whether
other clients might be accessing the singleton session bean at the same
time.

From the Bean Provider’s perspective, there
are two approaches for controlling singleton session bean concurrency
behavior:

container-managed concurrency: the container
controls concurrent access to the bean instance based on method-level
locking metadata

bean-managed concurrency: the container
allows full concurrent bean instance access and defers state
synchronization responsibility to the Bean Provider

When designing a singleton session bean, the
bean provider must decide whether the bean will use container-managed or
bean-managed concurrency. Typically singleton session beans will be
specified to have container-managed concurrency. This is the default if
no concurrency management type is specified. A singleton session bean
can be designed to use either container-managed concurrency or
bean-managed concurrency but it cannot use both.

The lifecycle of any interceptor classes
associated with a singleton session bean have the same lifecycle and
concurrency behavior as that of the singleton session bean itself. Each
interceptor class will be instantiated once per singleton session bean
instance. Any state stored in an instance of an interceptor class
associated with a singleton session bean should be considered when
devising the concurrency plan for the bean.

It is legal to store Java EE objects that do
not support concurrent access (e.g. references to Java Persistence
entity managers or stateful session beans) within the singleton session
bean instance state. However, it is the responsibility of the Bean
Provider to ensure such objects are not accessed by more than one thread
at a time.

Independent of the bean’s concurrency
management type, the container must ensure that no concurrent access to
the singleton session bean instance occurs until after the instance has
successfully completed its initialization sequence, including any
PostConstruct lifecycle callback method(s). The container must
temporarily block any singleton session bean access attempts that arrive
while the singleton session bean is still initializing.

Independent of the bean’s concurrency
management type, the container must ensure that concurrent access to the
SessionContext object is thread-safe.

Singleton session beans support reentrant
calls, i.e., where an outbound call from a singleton session bean method
results in a loopback call to the singleton session bean on the same
thread. Reentrant singleton session beans should be programmed and used
with caution. Special locking semantics apply to loopback calls on
singleton session beans with container-managed concurrency as described
below.

===== Container-Managed Concurrency

With container-managed concurrency, the
container is responsible for controlling concurrent access to the bean
instance based on method-level locking metadata. Each business method or
timeout method is associated with either a read (shared) lock or a write
(exclusive) lock.

If the container invokes a method associated
with a read lock, any number of other concurrent invocations on methods
with read locks are allowed to access the bean instance simultaneously.

If the container invokes a method associated
with a write lock, no other concurrent invocations will be allowed to
proceed until the method holding the write lock completes its
processing.

A concurrent access attempt that is not
allowed to proceed due to locking is blocked until it can make forward
progress. Timeouts can be specified via metadata so that a blocked
request can be rejected if a lock is not acquired within a certain
amount of time. If a singleton session bean invocation is rejected due
to lock timeout the ConcurrentAccessTimeoutException is thrown to the
client.

This specification only mandates the basic
read and write locking semantics outlined above. There are many policy
decisions that a container could make to affect the performance of the
locking scheme for a given application. For example:

Determining whether to grant forward progress
to a read method or write method, when both readers and writers are
waiting at the time that a write method completes.

Determining whether to allow additional
readers while one or more readers is active and a writer is waiting.

The exact set of additional read/write
locking policy decisions supported by a Container Provider and the
configuration requirements for those policies are outside the scope of
this specification.

====== Reentrant Locking Behavior

Special locking semantics apply to loopback
calls on singleton session beans with container-managed concurrency.

If a loopback call occurs on a singleton
session bean that already holds a write lock on the same thread:

If the target of the loopback call is a read
method, the read lock must always be granted immediately, without
releasing the original write lock.

If the target of the loopback call is a write
method, the call must proceed immediately, without releasing the
original write lock.

If a loopback call occurs on a singleton
session bean that holds a read lock on the same thread (but does not
also hold a write lock on the same thread):

If the target of the loopback call is a read
method, the call must proceed immediately, without releasing the
original Read lock.

If the target of the loopback call is a write
method, the javax.ejb.IllegalLoopbackException must be thrown to the
caller.

===== Bean-Managed Concurrency

With bean-managed concurrency, the container
allows full concurrent access to the singleton session bean instance. It
is the responsibility of the Bean Provider to guard its state as
necessary against synchronization errors due to concurrent access. The
Bean Provider is permitted to use the Java language level
synchronization primitives such as synchronized and volatile for this
purpose.

===== Specification of a Concurrency Management Type

By default, a singleton session bean has
container-managed concurrency. The Bean Provider of a singleton session
bean can use the ConcurrencyManagement annotation on the bean class to
declare the bean’s concurrency management type.

Alternatively, the Bean Provider can use the
deployment descriptor to specify the bean’s concurrency management type.
If the deployment descriptor is used, it is only necessary to explicitly
specify the bean’s concurrency management type if bean-managed
concurrency is used.

The concurrency management type of a
singleton session bean is determined by the Bean Provider. The
Application Assembler is not permitted to use the deployment descriptor
to override a bean’s concurrency management type regardless of whether
it has been explicitly specified or defaulted by the Bean Provider. (See
Chapter link:Ejb.html#a5804[See Deployment Descriptor] for
information about the deployment descriptor.)

===== Specification of the Container-Managed Concurrency Metadata for a Bean’s Methods

The Bean Provider of a singleton session bean
with container-managed concurrency may specify locking metadata for the
enterprise bean’s methods. By default, the value of the lock associated
with a method of a bean with container managed concurrency is a write
lock (exclusive lock).

A concurrency locking attribute is a value
associated with each of the following methods:

a method of a bean’s business interface

a method of a bean’s no-interface view

a timeout callback method

a web service endpoint method

The concurrency locking attribute specifies
how the container must manage concurrency when a client invokes the
method.

Concurrency locking attributes are specified
for the following methods:

For a bean written to the EJB 3.x client view
API, the concurrency locking attributes are specified for those methods
of the bean class that correspond to the bean’s business interface, the
direct and indirect superinterfaces of the business interface, methods
exposed through the no-interface view, and for timeout callback methods,
if any.

For a bean that provides a web service client
view, the concurrency locking attributes are specified for those methods
of the bean class that correspond to the bean’s web service endpoint
methods, and for timeout callback methods, if any.

The following rules apply to the
specification of concurrency attributes.

The Lock(READ) and Lock(WRITE)annotations are
used to specify concurrency locking attributes.

The concurrency locking attributes for the
methods of a bean class may be specified on the class, the business
methods of the class, or both.

Specifying the Lock annotation on the bean
class means that it applies to all applicable business methods of the
class. If the concurrency locking attribute is not specified, it is
assumed to be Lock(WRITE). The absence of a concurrency attribute
specification on the bean class is equivalent to the specification of
Lock(WRITE)on the bean class.

A concurrency locking attribute may be
specified on a method of the bean class to override the concurrency
locking attribute value explicitly or implicitly specified on the bean
class.

If the bean class has superclasses, the
following additional rules apply:

A concurrency locking attribute specified on
a superclass S appplies to the business methods defined by S. If a
class-level concurrency attribute is not specified on S, it is
equivalent to specification of Lock(WRITE)on S.

A concurrency locking attribute may be
specified on a business method M defined by class S to override for
method M the concurrency locking attribute value explicitly or
implicitly specified on the class S.

If a method M of class S overrides a business
method defined by a superclass of S, the concurrency locking attribute
of M is determined by the above rules as applied to class S.

The Bean Provider may use the deployment
descriptor as an alternative to metadata annotations to specify the
concurrency locking attributes. Concurrency locking attributes specified
in the deployment descriptor are assumed to override or supplement
concurrency locking attributes specified in annotations. If a
concurrency locking attribute value is not specified in the deployment
descriptor, it is assumed that the concurrency locking attribute
specified in annotations applies, or — in the case that no annotation
has been specified —that the value is Write.

The Application Assembler is permitted to
override the concurrency locking attribute values using the bean’s
deployment descriptor. The Deployer is also permitted to override the
concurrency locking attribute values at deployment time. Caution should
be exercised when overriding the concurrency locking attributes of an
application, as the concurrency structure of an application is typically
intrinsic to the semantics of the application.

Example:

@Lock(READ)

public class SomeClass \{

 public void aMethod () \{ ... }

 public void bMethod () \{ ... }

 ...

}



@Singleton public class ABean extends
SomeClass implements A \{



 public void aMethod () \{ ... }



 @Lock(WRITE)

 public void cMethod () \{ ... }



 ...

}



Assuming that aMethod, bMethod, cMethod of
singleton session bean ABean are methods of business interface A, their
concurrency locking attributes are Lock(WRITE), Lock(READ), and
Lock(WRITE)respectively.

===== Concurrent Access Timeouts

A concurrent access attempt that cannot
immediately acquire the appropriate lock is blocked until it can make
forward progress. The AccessTimeout annotation is used to specify the
amount of time the access attempt should be blocked before timing out.
Access timeouts only apply to methods eligible for concurrency locks on
a singleton session bean with container-managed concurrency. If an
access attempt times out, the container throws the
javax.ejb.ConcurrentAccessTimeoutException to the client.

The AccessTimeout annotation can be specified
on a business method or on a bean class (or superclass). An
AccessTimeout annotation specified on a class applies the access timeout
to all business methods of that class. If the AccessTimeout annotation
is specified on both a class and on a business method of that class, the
method-level annotation takes precedence.

An _AccessTimeout_ value of -1 indicates that
the client request will block indefinitely until forward progress can be
made.

An AccessTimeout value of 0 indicates that
concurrent access is not allowed. Access attempts on methods with a
timeout value of 0 result in the javax.ejb.ConcurrentAccessException.

==== Operations Allowed in the Methods of a Singleton Session Bean

Table link:Ejb.html#a1343[See
Operations Allowed in the Methods of a Singleton Session Bean] defines
the methods of a singleton session bean class in which the session bean
instances can access the methods of the javax.ejb.SessionContext
interface, the java:comp/env environment naming context, resource
managers, _TimerService_ and _Timer_ methods, the _EntityManager_ and
_EntityManagerFactory_ methods, and other enterprise beans.

If a session bean instance attempts to invoke
a method of the SessionContext interface, and the access is not allowed
in Table link:Ejb.html#a1343[See Operations Allowed in the
Methods of a Singleton Session Bean], the container must throw the
java.lang.IllegalStateException.

If a session bean instance attempts to invoke
a method of the _TimerService_ or _Timer_ interface and the access is
not allowed in Table link:Ejb.html#a1343[See Operations Allowed
in the Methods of a Singleton Session Bean], the container must throw
the _java.lang.IllegalStateException_ .

If a session bean instance attempts to access
a resource manager, an enterprise bean, an entity manager or entity
manager factory, and the access is not allowed in Table
link:Ejb.html#a1343[See Operations Allowed in the Methods of a
Singleton Session Bean], the behavior is undefined by the EJB
architecture.

===



[[a1343]]Operations Allowed in the Methods of a Singleton
Session Bean

Bean method





Bean method can perform the following
operations



Container-managed transaction demarcation

Bean-managed transaction demarcation

constructor

-

-

dependency injectionmethods

SessionContext methods: lookup

JNDI access to java:comp/env

SessionContext methods: lookup

JNDI access to java:comp/env

PostConstruct, PreDestroy lifecycle
callback interceptor methods footnote:a10252[If a client calls lifecycle 
callback method through a business interface or a no-interface view, 
the method is treated like a business method.]

SessionContext methods: _getBusinessObject_ ,
getRollbackOnly, setRollbackOnly, getTimerService, lookup,
getContextData

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

SessionContext methods: _getBusinessObject,_
getUserTransaction, getTimerService, lookup, getContextData

UserTransaction methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManager access

EntityManagerFactory access

TimerService and Timer methods

business method

from business interface or from no-interface
view ; business method interceptor method

SessionContext methods: _getBusinessObject_ ,
getCallerPrincipal, isCallerInRole, getRollbackOnly, setRollbackOnly,
getTimerService, getInvokedBusinessInterface, wasCancelCalled, lookup,
getContextData

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

SessionContext methods: _getBusinessObject,_
getCallerPrincipal, isCallerInRole, getUserTransaction, getTimerService,
getInvokedBusinessInterface, wasCancelCalled, lookup, getContextData

UserTransaction methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

business method

from web service endpoint

SessionContext methods: _getBusinessObject,_
getCallerPrincipal, isCallerInRole, getRollbackOnly, setRollbackOnly,
getTimerService, getMessageContext, lookup, getContextData

Message context methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

SessionContext methods: _getBusinessObject_ ,
getCallerPrincipal, isCallerInRole, getUserTransaction, getTimerService,
getMessageContext, lookup, getContextData

UserTransaction methods

Message context methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

timeout callback method

SessionContext methods: _getBusinessObject_ ,
getCallerPrincipal, isCallerInRole, getRollbackOnly, setRollbackOnly,
getTimerService, lookup, getContextData

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

SessionContext methods: _getBusinessObject_ ,
getCallerPrincipal, isCallerInRole, getUserTransaction, getTimerService,
lookup, getContextData

UserTransaction methods

JNDI access to java:comp/env

Resource manager access

Enterprise bean access

EntityManagerFactory access

EntityManager access

TimerService and Timer methods

Additional restrictions:

The getRollbackOnly and setRollbackOnly
methods of the SessionContext interface should be used only in the
session bean methods that execute in the context of a transaction. The
container must throw the java.lang.IllegalStateException if the methods
are invoked while the current business method is not executing in the
context of a transaction.

Invoking the _wasCancelCalled_ method is
disallowed except when inside the context of the asynchronous methods
that declare Future<V> object as the returning type

The reasons for disallowing operations in
Table link:Ejb.html#a1343[See Operations Allowed in the Methods
of a Singleton Session Bean]:

Invoking the _getBusinessObject_ method is
disallowed if the session bean does not define a business interface or a
no-interface view.

Invoking the _getInvokedBusinessInterface_
method is disallowed if the session bean does not define a business
interface or a no-interface view. It is also disallowed if the current
business method was not invoked through a business interface or the
no-interface view.

Invoking the _getEJBObject_ and _getEJBHome_
methods is disallowed since a singleton session bean does not support
the EJB 2.x remote client view.

Invoking the _getEJBLocalObject_ and
_getEJBLocalHome_ methods is disallowed since a singleton session bean
does not support the EJB 2.x local client view.

Invoking the getRollbackOnly and
setRollbackOnly methods is disallowed in the session bean methods for
which the container does not have a meaningful
transaction context, and for all session
beans with bean-managed transaction
demarcation.

Invoking the _getMessageContext_ method is
disallowed in session bean methods that were not invoked by the
container through the session bean’s web service endpoint.

Accessing resource managers, enterprise
beans, and the EntityManager is disallowed in the session bean methods
for which the container does not have a meaningful transaction context
and/or client security context.

The UserTransaction interface is unavailable
to session beans with container-managed
transaction demarcation.

=== The Responsibilities of the Bean Provider



This section
describes the responsibilities of the session Bean Provider to ensure
that a session bean can be deployed in any EJB container. These
requirements apply to stateful session beans, stateless session beans,
and singleton session beans.

==== Classes and Interfaces

The session Bean
Provider is responsible for providing the following class
files:footnote:a10253[Note that the interfaces provided by the Bean 
Provider may have been generated by tools.]

Session bean class.

Session bean’s business interface(s), if the
session bean provides an EJB 3.x local or remote client view.

Session bean’s remote interface and remote
home interface, if the session bean provides an EJB 2.1
remote client view.

Session bean’s local interface and local home
interface, if the session bean provides an EJB 2.1
local client view.

Session bean’s web service endpoint
interface, if any.

Interceptor classes, if any.

The Bean Provider for a session bean that
provides a web service client view may also define JAX-WS message
handlers for the bean. The requirements for such message handlers are
defined in link:Ejb.html#a9879[See Web Services for Java EE,
version 1.3. http://jcp.org/en/jsr/detail?id=109.] and
link:Ejb.html#a9881[See Java™ API for XML-based Web Service,
version 2.2 (JAX-WS). http://jcp.org/en/jsr/detail?id=224.].

==== Session Bean Class

The following are
the requirements for the session bean class:

The class must be defined as public, must not
be _final_ , and must not be abstract. The class must be a top level
class.

The class must have a public constructor that
takes no parameters. The EJB container uses this constructor to create
instances of the session bean class.

The class must not define the finalize()
method.

The class must implement the bean’s business
interface(s) or the methods of the bean’s business interface(s), if any.

{empty}The class must implement the business
methods of the bean’s EJB 2.1 client view interfaces, if any.
footnote:a10254[Note that the EJB 2.x client view is not supported for 
singleton session beans.]

Optionally:

The class may have an additional constructor
annotated with the Inject annotation (see
link:Ejb.html#a195[See Relationship to Contexts and Dependency
Injection (CDI) Specification] and the CDI specification
link:Ejb.html#a9888[See Contexts and Dependency Injection for
the Java EE Platform 1.1 (CDI specification)
http://jcp.org/en/jsr/detail?id=346.]).

{empty}The class may implement, directly or
indirectly, the javax.ejb.SessionBean interface.footnote:a10255[Except 
for singleton session beans.]

If the class is a stateful session bean, it
may implement the javax.ejb.SessionSynchronization interface or use one
or more of the session synchronization annotations.

The class may implement the session bean’s
web service endpoint or component interface.

If the class is a stateless session bean, it
may implement the _javax.ejb.TimedObject_ interface. See
link:Ejb.html#a5456[See Timer Service].

The class may implement the ejbCreate
method(s).

The session bean class may have superclasses
and/or superinterfaces. If the session bean has superclasses, the
business methods, lifecycle callback interceptor methods, the timeout
callback methods, the methods implementing the optional session
synchronization notifications, the _Init_ or ejbCreate _<METHOD>_
methods, the _Remove_ methods, and the methods of the SessionBean
interface may be defined in the session bean class or in any of its
superclasses.

The session bean class is allowed to
implement other methods (for example helper methods invoked internally
by the business methods) in addition to the methods required by the EJB
specification.

===== Session Bean Superclasses

A session bean class is permitted to have
superclasses that are themselves session bean classes. However, there
are no special rules that apply to the processing of annotations or the
deployment descriptor for this case. For the purposes of processing a
particular session bean class, all superclass processing is identical
regardless of whether the superclasses are themselves session bean
classes. In this regard, the use of session bean classes as superclasses
merely represents a convenient use of implementation inheritance, but
does not have component inheritance semantics.

For example, the client views exposed by a
particular session bean are not inherited by a subclass that also
happens to define a session bean.

@Stateless

public class A implements Foo \{ ... }



@Stateless

public class B extends A implements Bar \{
... }



Assuming Foo and Bar are local business
interfaces and there is no associated deployment descriptor, session
bean A exposes local business interface Foo and session bean B exposes
local business interface Bar, but not Foo.

Session bean B would need to explicitly
include Foo in its set of exposed views for that interface to apply. For
example:

@Stateless

public class A implements Foo \{ ... }



@Stateless

public class B extends A implements Foo, Bar
\{ ... }

[[a1487]]
==== Lifecycle Callback Interceptor Methods

{empty}The AroundConstruct, _PostConstruct_ ,
_PreDestroy_ , _PrePassivate_ , and _PostActivate_ lifecycle callback
interceptor methods may be defined for session beans. If the
_PrePassivate_ or _PostActivate_ lifecycle callbacks are defined for
stateless session beans or singleton session beans, they are
ignored.footnote:a10256[Note that this might result from the use of 
default interceptors, for example.]

The AroundConstruct lifecycle callback
interceptor method may be defined on an interceptor class only. All
other lifecycle callback interceptor methods may be defined on the bean
class and/or on an interceptor class of the bean. Rules applying to the
definition of lifecycle callback interceptor methods are defined in
Section link:Ejb.html#a2023[See Interceptors for LifeCycle Event
Callbacks] .

If the _PostConstruct_ lifecycle callback
interceptor method is the _ejbCreate_ method, if the _PreDestroy_
lifecycle callback interceptor method is the _ejbRemove_ method, if the
_PostActivate_ lifecycle callback interceptor method is the
_ejbActivate_ method, or if the _PrePassivate_ lifecycle callback
interceptor method is the _ejbPassivate_ method, these callback methods
must be implemented on the bean class itself (or on its superclasses).
Except for these cases, the method names can be arbitrary, but must not
start with “ejb” to avoid conflicts with the callback methods defined by
the javax.ejb.EnterpriseBean interfaces.

==== Session Synchronization Methods

The bean class (or superclass) of a stateful
session bean may use one or more of the session synchronization
annotations AfterBegin, BeforeCompletion, and AfterCompletion. Each bean
has at most one session synchronization method for each of the three
annotation types. In the case of method overriding of session
synchronization methods declared by annotations, the most derived method
takes precedence. The signatures of the session synchronization methods
must follow these rules:

The method must not be declared as final or
static.

The method may have any access type: public,
private, protected, or package-level.

The return type must be void.

The AfterBegin and BeforeCompletion methods
must take 0 arguments.

The AfterCompletion method must take a single
argument of type boolean.

[[a1498]]
==== ejbCreate<METHOD> Methods

The session bean
class of a session bean that has a home interface may define one or more
ejbCreate<METHOD> methods. These _ejbCreate_ methods are intended for
use only with components written to the the EJB 2.1 and earlier APIs.
The signatures of the _ejbCreate_ methods must follow these rules:

The method name must have ejbCreate as its
prefix.

The method must be declared as public.

The method must not be declared as final or
static.

The return type must be void.

The method arguments must be legal types for
RMI/IIOP if there is a _create<METHOD>_ corresponding to the
ejbCreate<METHOD> method on the session bean’s remote home interface.

A stateless session bean may define only a
single _ejbCreate_ method, with no arguments.

The _throws_ clause may define arbitrary
application exceptions, possibly including the
javax.ejb.CreateException.

EJB 1.0 allowed the _ejbCreate_ method to
throw the java.rmi.RemoteException to indicate a non-application
exception. This practice was deprecated in EJB 1.1—an EJB 1.1 or EJB 2.0
or later compliant enterprise bean should throw the
_javax.ejb.EJBException_ or another _RuntimeException_ to indicate
non-application exceptions to the container (see Section
link:Ejb.html#a2986[See System Exceptions]). An EJB 2.0 and
later compliant enterprise bean should not throw the
java.rmi.RemoteException from the _ejbCreate_ method .

==== Business Methods

The session bean
class may define zero or more business methods whose signatures must
follow these rules:

The method names can be arbitrary, but they
must not start with “ejb” to avoid conflicts with the callback methods
used by the EJB architecture.

The method must be declared as public.

The method must not be declared as final or
static.

The argument and return value types for the
method must be legal types for RMI/IIOP if the method corresponds to a
business method on the session bean’s remote business interface or
remote component interface.

The argument and return value types for a
method must be legal types for JAX-WS if the method is a web service
method or corresponds to a method on the session bean’s web service
endpoint.

The _throws_ clause may define arbitrary
application exceptions.

[[a1516]]Note:
Callback methods are permitted to have public access type. This raises
the question of whether a callback method can also be exposed as a
business method through one or more client views. Doing so is not
prohibited, but should be done with caution. The runtime context (e.g.
transaction context, caller principal, operations allowed, etc.) for a
method invoked as a callback can differ significantly from the context
for the same method when invoked via a client invocation. As a general
rule, callback methods should not be exposed as business methods.
Therefore, it is recommended that all non-business methods be assigned
an access type other than public.

EJB 1.0 allowed the business methods to throw
the java.rmi.RemoteException to indicate a non-application exception.
This practice was deprecated in EJB 1.1—an EJB 1.1 or EJB 2.0 or later
compliant enterprise bean should throw the _javax.ejb.EJBException_ or
another _RuntimeException_ to indicate non-application exceptions to the
container (see Section link:Ejb.html#a2986[See System
Exceptions]). An EJB 2.0 or later compliant enterprise bean should not
throw the java.rmi.RemoteException from a business method.

[[a1518]]
==== Session Bean’s Business Interface

The following are
the requirements for the session bean’s business interface:

The interface must not extend the
javax.ejb.EJBObject or javax.ejb.EJBLocalObject interface.

If the business interface is a remote
business interface, the argument and return values must be of valid
types for RMI/IIOP. The remote business interface is not required or
expected to be a _java.rmi.Remote_ interface. The _throws_ clause should
not include the java.rmi.RemoteException. The methods of the business
interface may only throw the _java.rmi.RemoteException_ if the interface
extends _java.rmi.Remote_ .

The interface is allowed to have
superinterfaces.

If the interface is a remote business
interface, its methods must not expose local interface types, timers or
timer handles as arguments or results.

{empty}The same business interface cannot be
both a local and a remote business interface of the
bean.footnote:a10257[It is also an error if the `Local` and/or `Remote` 
annotations are specified both on the bean class and on the referenced 
interface and the values differ.]

The bean class must implement the interface
or the interface must be designated as a local or remote business
interface of the bean by means of the _Local_ or _Remote_ annotation or
in the deployment descriptor. The following rules apply to the
interfaces implemented by the bean class:

 _java.io.Serializable_ ,
_java.io.Externalizable_ and the interfaces defined by the _javax.ejb_
package are excluded when determining whether the bean class has
business interfaces.

All business interfaces must be explicitly
designated as such if any of the following is true:

the bean exposes a no-interface view

any interface of the bean class is explicitly
designated as a business interface of the bean by either of the
following means:

using the Local or Remote annotation with a
non-empty value on the bean class

using the Local or Remote annotation on the
interface

in the deployment descriptor

Otherwise:

If the bean class is annotated with the
Remote annotation, all implemented interfaces (excluding the interfaces
listed above) are assumed to be remote business interfaces of the bean.

If the bean class is annotated with the Local
annotation, or if the bean class is annotated with neither the Local nor
the Remote annotation, all implemented interfaces (excluding the
interfaces listed above) are assumed to be local business interfaces of
the bean.

Note that while it is expected that the bean
class will typically implement its business interface(s), if the bean
class uses annotations or the deployment descriptor to designate its
business interface(s), it is not required that the bean class also be
specified as implementing the interface(s).

The following examples assume that there is
no deployment descriptor associated with the bean and neither the Local
nor the Remote annotation is specified on the bean class or an interface
unless noted.

Example 1: session bean A exposes two local
business interfaces, Foo and Bar:



public interface Foo \{ ... }



public interface Bar \{ ... }



@Stateless

public class A implements Foo, Bar \{ ... }





Example 2: session bean A exposes two local
business interfaces, Foo and Bar:



public interface Foo \{ ... }



public interface Bar \{ ... }



@Local

@Stateless

public class A implements Foo, Bar \{ ... }



Example 3: session bean A exposes two remote
business interfaces, Foo and Bar



public interface Foo \{ ... }



public interface Bar \{ ... }



@Remote

@Stateless

public class A implements Foo, Bar \{ ... }



Example 4: session bean A exposes only one
remote business interface Foo



@Remote

public interface Foo \{ ... }



public interface Bar \{ ... }



@Stateless

public class A implements Foo, Bar \{ ... }



Example 5: session bean A exposes only one
remote business interface Foo



public interface Foo \{ ... }



public interface Bar \{ ... }



@Remote(Foo.class)

@Stateless

public class A implements Foo, Bar \{ ... }

==== Session Bean’s No-Interface View

The following are the requirements for a
session bean that exposes a no-interface view:

The bean class must designate that it exposes
a no-interface view via its bean class definition or in the deployment
descriptor. The following rules apply:

If the bean does not expose any other client
views (local, remote, no-interface, 2.x Remote Home, 2.x Local Home, Web
Service) and its implements clause is empty, the bean defines a
no-interface view.

If the bean exposes at least one other client
view, the bean designates that it exposes a no-interface view by means
of the LocalBean annotation on the bean class or in the deployment
descriptor.

The following interfaces are excluded when
determining whether the bean exposes a no-interface view:
_java.io.Serializable_ ; _java.io.Externalizable_ ; any of the
interfaces defined by the _javax.ejb_ package.

All non-static public methods of the bean
class and of any superclasses except java.lang.Object are exposed as
business methods through the no-interface view.

Note: This includes callback methods. The
Bean Provider should exercise caution when choosing to expose callback
methods as business methods through the no-interface view. The runtime
context (e.g. transaction context, caller principal, operations allowed,
etc.) for a method invoked as a callback can differ significantly from
the context for the same method when invoked via a client invocation. In
general, callback methods should not be exposed as business methods.
Therefore, it is recommended that all non-business methods be assigned
an access type other than public.

The throws clause of a bean class method
exposed through the no-interface view must not include the
java.rmi.RemoteException.

Only private methods of the bean class and
any superclasses except java.lang.Object may be declared final.

==== Session Bean’s Remote Component Interface

The following are
the requirements for the session bean’s remote component interface:

The interface must extend the
javax.ejb.EJBObject interface.

The methods defined in this interface must
follow the rules for RMI/IIOP. This means that their argument and return
values must be of valid types for RMI/IIOP, and their _throws_ clauses
must include the java.rmi.RemoteException.

The remote component interface is allowed to
have superinterfaces. Use of interface inheritance is subject to the
RMI/IIOP rules for the definition of remote interfaces.

For each method defined in the remote
component interface, there must be a matching method in the session
bean’s class. The matching method must have:

The same name.

The same number and types of arguments, and
the same return type.

All the exceptions defined in the _throws_
clause of the matching method of the session bean class must be defined
in the _throws_ clause of the method of the remote component interface.

The remote component interface methods must
not expose local component interface types, local home interface types,
timers or timer handles as arguments or results.

==== Session Bean’s Remote Home Interface

The following are
the requirements for the session bean’s
remote home interface:

The interface must extend the
javax.ejb.EJBHome interface.

The methods defined in this interface must
follow the rules for RMI/IIOP. This means that their argument and return
values must be of valid types for RMI/IIOP, and that their _throws_
clauses must include the java.rmi.RemoteException.

The remote home interface is allowed to have
superinterfaces. Use of interface inheritance is subject to the RMI/IIOP
rules for the definition of remote interfaces.

A session bean’s
remote home interface must define one or
more create<METHOD> methods. A stateless session bean must define
exactly one create method with no arguments.

Each create method of a stateful session bean
must be named _create<METHOD>_ , and it must match one of the _Init_
methods or ejbCreate<METHOD> methods defined in the session bean class.
The matching _Init_ method or ejbCreate<METHOD> method must have the
same number and types of arguments. (Note that the return type is
different.) The _create_ method for a stateless session bean must be
named “ _create_ ” but need not have a matching “ _ejbCreate_ ” method.

The return type for a create _<METHOD>_
method must be the session bean’s remote component interface type.

All the exceptions defined in the _throws_
clause of an ejbCreate _<METHOD>_ method of the session bean class must
be defined in the _throws_ clause of the matching create _<METHOD>_
method of the remote home interface.

The _throws_ clause must include
javax.ejb.CreateException.

==== Session Bean’s Local Component Interface

The following are
the requirements for the session bean’s local component interface:

The interface must extend the
javax.ejb.EJBLocalObject interface.

The _throws_ clause of a method defined in
the local interface must not include the java.rmi.RemoteException.

The local component interface is allowed to
have superinterfaces.

For each method defined in the local
component interface, there must be a matching method in the session
bean’s class. The matching method must have:

The same name.

The same number and types of arguments, and
the same return type.

All the exceptions defined in the _throws_
clause of the matching method of the session bean class must be defined
in the _throws_ clause of the method of the local component interface.

==== Session Bean’s Local Home Interface

The following are
the requirements for the session bean’s local home interface:

The interface must extend the
javax.ejb.EJBLocalHome interface.

The _throws_ clause of a method in the local
home interface must not include the java.rmi.RemoteException.

The local home
interface is allowed to have superinterfaces.

A session bean’s local home interface must
define one or more create<METHOD> methods. A stateless session bean must
define exactly one create method with no arguments.

Each create method of a stateful session bean
must be named _create<METHOD>_ , and it must match one of the _Init_
methods or ejbCreate<METHOD> methods defined in the session bean class.
The matching _Init_ method or ejbCreate<METHOD> method must have the
same number and types of arguments. (Note that the return type is
different.) The _create_ method for a stateless session bean must be
named “ _create_ ” but need not have a matching “ _ejbCreate_ ” method.

The return type for a create _<METHOD>_
method must be the session bean’s local component interface type.

All the exceptions defined in the _throws_
clause of an ejbCreate _<METHOD>_ method of the session bean class must
be defined in the _throws_ clause of the matching create _<METHOD>_
method of the local home interface.

The _throws_
clause must include
javax.ejb.CreateException.

==== Session Bean’s Web Service Endpoint Interface

The EJB 3.x API does not require the
definition of a web service endpoint interface for session beans that
implement a web service endpoint.

The JAX-WS and Web Services for Java EE
specifications do not require that a separate interface be defined for a
web service endpoint. The requirements for web service endpoints under
JAX-WS and Web Services for Java EE are given in
link:Ejb.html#a9881[See Java™ API for XML-based Web Service,
version 2.2 (JAX-WS). http://jcp.org/en/jsr/detail?id=224.] and
link:Ejb.html#a9879[See Web Services for Java EE, version 1.3.
http://jcp.org/en/jsr/detail?id=109.].

=== The Responsibilities of the Container Provider



This section
describes the responsibilities of the Container Provider to support a
session bean. The Container Provider is responsible for providing the
deployment tools and for managing the session bean instances at runtime.

Because the EJB specification does not define
the API between deployment tools and the container, we assume that the
deployment tools are provided by the Container Provider. Alternatively,
the deployment tools may be provided by a different vendor who uses the
container vendor’s specific API.

==== Generation of Implementation Classes

The deployment tools provided by the
container are responsible for the generation of additional classes when
the session bean is deployed. The tools obtain the information that they
need for generation of the additional classes by introspecting the
classes and interfaces provided by the Bean Provider and by examining
the session bean’s deployment descriptor.

The deployment
tools must generate the following classes:

A class that implements the session bean’s
business interface.

A class that implements the session bean’s
no-interface view.

A class that implements the session bean’s
remote home interface (session EJBHome class).

A class that implements the session bean’s
remote component interface (session EJBObject class).

A class that implements the session bean’s
local home interface (session EJBLocalHome class).

A class that implements the session bean’s
local component interface (session EJBLocalObject class).

A class that implements the session bean’s
web service endpoint.

A class that implements the return value of
an asynchronous method with return type _Future<V>_ .

The deployment
tools may also generate a class that mixes some container-specific code
with the session bean class. This code may, for example, help the
container to manage the bean instances at runtime. The tools can use
subclassing, delegation, and code generation.

The deployment tools may also allow the
generation of additional code that wraps the business methods and is
used to customize the business logic to an existing operational
environment. For example, a wrapper for a debit function on the
AccountManager bean may check that the debited amount does not exceed a
certain limit.

==== Generation of WSDL

Reference link:Ejb.html#a9879[See Web
Services for Java EE, version 1.3. http://jcp.org/en/jsr/detail?id=109.]
describes the generation of a WSDL document for a web service endpoint.
The Java to WSDL mapping must adhere to the requirements of JAX-WS
link:Ejb.html#a9881[See Java™ API for XML-based Web Service,
version 2.2 (JAX-WS). http://jcp.org/en/jsr/detail?id=224.].

==== Session Business Interface Implementation Class

The container’s implementation of the
session business interface, which is
generated by the deployment tools, implements the business methods
specific to the session bean.

The implementation of each business method
must activate the instance (if the instance is in the passive state),
invoke any business method interceptor methods, and invoke the matching
business method on the instance.

The Container Provider is responsible for
providing the implementation of the _equals_ and _hashCode_ methods for
the business interface, in conformance with the requirements of section
link:Ejb.html#a342[See Session Object Identity].

==== No-Interface View Reference Class

The container’s implementation of the
no-interface view reference, which is generated by the deployment tools,
implements the business methods that are exposed to the no-interface
view client.

The implementation of each business method
must activate the instance (if the instance is in the passive state),
invoke any business method interceptor methods, and invoke the matching
business method on the instance.

The Container Provider is responsible for
providing the implementation of the _equals_ and _hashCode_ methods for
the no-interface view reference class, in conformance with the
requirements of section link:Ejb.html#a519[See Client view of
Session Object’s Life Cycle].

==== Session EJBHome Class

The session
EJBHome class, which is generated by the deployment tools, implements
the session bean’s remote home interface. This class implements the
methods of the javax.ejb.EJBHome interface and the create<METHOD>
methods specific to the session bean.

The implementation of each create<METHOD>
method invokes a matching ejbCreate<METHOD> method.

==== Session EJBObject Class

The session
EJBObject class, which is generated by the deployment tools, implements
the session bean’s remote component interface. It implements the methods
of the javax.ejb.EJBObject interface and the business methods specific
to the session bean.

The implementation of each business method
must activate the instance (if the instance is in the passive state),
invoke any business method interceptor methods, and invoke the matching
business method on the instance.

==== Session EJBLocalHome Class

The session
EJBLocalHome class, which is generated by the deployment tools,
implements the session bean’s local home interface. This class
implements the methods of the javax.ejb.EJBLocalHome interface and the
create<METHOD> methods specific to the session bean.

The implementation of each create<METHOD>
method invokes a matching ejbCreate<METHOD> method.

==== Session EJBLocalObject Class

The session
EJBLocalObject class, which is generated by the deployment tools,
implements the session bean’s local component interface. It implements
the methods of the javax.ejb.EJBLocalObject interface and the business
methods specific to the session bean.

The implementation of each business method
must activate the instance (if the instance is in the passive state),
invoke any business method interceptor methods, and invoke the matching
business method on the instance.

==== Web Service Endpoint Implementation Class

The implementation class for a stateless
session bean’s web service endpoint is generated by the container’s
deployment tools. This class must handle requests to the web service
endpoint, unmarshall the SOAP request, invoke any business method
interceptor methods, and invoke the stateless session bean method that
matches the web service endpoint method that corresponds to the request.

==== Asynchronous Client Future<V> Return Value Implementation Class

The object returned from an asynchronous
method with return type _Future<V>_ is implemented by the container’s
deployment tools.

==== Handle Classes

The deployment
tools are responsible for implementing the
handle classes for the session bean’s remote
home and remote component interfaces.

==== EJBMetaData Class

The deployment tools are responsible for
implementing the class that provides metadata to the remote client view
contract. The class must be a valid RMI Value class and must implement
the javax.ejb.EJBMetaData interface.

==== Non-reentrant Instances

The container must ensure that only one
thread can be executing a stateless or stateful session bean
instance at any time. Therefore, stateful
and stateless session beans do not have to be coded as reentrant. One
implication of this rule is that an application cannot make loopback
calls to a stateless or stateful session bean instance.

==== Transaction Scoping, Security, Exceptions

The container
must follow the rules with respect to transaction scoping, security
checking, and exception handling, as described in Chapters
link:Ejb.html#a2172[See Support for Transactions],
link:Ejb.html#a4945[See Security Management], and
link:Ejb.html#a2940[See Exception Handling], respectively.

==== JAX-WS Message Handlers for Web Service Endpoints

The container must support the use of JAX-WS
message handlers for web service endpoints. Container requirements for
support of message handlers are specified in
link:Ejb.html#a9881[See Java™ API for XML-based Web Service,
version 2.2 (JAX-WS). http://jcp.org/en/jsr/detail?id=224.] and
link:Ejb.html#a9879[See Web Services for Java EE, version 1.3.
http://jcp.org/en/jsr/detail?id=109.].

If message handlers are present, they must be
invoked before any business method interceptor methods.

==== SessionContext

The container must implement the
SessionContext.getEJBObject method such that the bean instance can use
the Java language cast to convert the returned value to the session
bean’s remote component interface type. Specifically, the bean instance
does not have to use the PortableRemoteObject.narrow method for the type
conversion.

The container must implement the
_EJBContext.lookup_ method such that when the _lookup_ method is used to
look up a bean’s remote home interface, a bean instance can use the Java
language cast to convert the returned value to a session bean’s remote
home interface type. Specifically, the bean instance does not have to
use the PortableRemoteObject.narrow method for the type conversion.
